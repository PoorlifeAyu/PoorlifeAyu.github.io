{"meta":{"title":"KeepSmiling","subtitle":null,"description":"己所不欲，勿施于人","author":"Ayu","url":""},"pages":[{"title":"","date":"2021-07-10T14:47:27.083Z","updated":"2021-07-10T14:47:27.083Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"Ayu with&nbsp; Angel&nbsp; （ you ） talking bot_ui_ini()","keywords":"我的个人介绍"},{"title":"bangumi","date":"2021-07-09T14:14:30.337Z","updated":"2021-07-09T14:14:30.337Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2021-07-09T14:14:48.449Z","updated":"2021-07-09T14:14:48.449Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"Hello World","keywords":"留言板"},{"title":"client","date":"2021-07-09T14:14:37.609Z","updated":"2021-07-09T14:14:37.609Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2021-07-09T14:15:05.595Z","updated":"2021-07-09T14:15:05.595Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":null},{"title":"","date":"2021-07-09T14:30:54.362Z","updated":"2021-07-09T14:30:54.362Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"嘻嘻嘻！暂时还没有想到内容…","keywords":null},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-07-19T11:49:07.710Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-07-07T09:55:33.562Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-07-25T16:31:50.853Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"博主喜欢的音乐"},{"title":"","date":"2021-07-09T15:07:28.782Z","updated":"2021-07-09T15:07:28.782Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-07-26T17:52:41.551Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2021-07-09T15:11:47.225Z","updated":"2021-07-09T15:11:47.225Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"","slug":"VueX","date":"2021-07-25T18:08:41.361Z","updated":"2021-07-27T16:53:05.484Z","comments":true,"path":"2021/07/26/VueX/","link":"","permalink":"/2021/07/26/VueX/","excerpt":"","text":"VuexVuex的定义 定义：vuex是一个vue里面的数据管理仓储中心，用于分发数据到具体组件。 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 什么时候使用Vuex 当复杂数据被两个组件以上使用的时候，我们可以考虑vuex来协助 Vuex配置引用 引入Vue和Vuex // 1.引入 import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; 注册 Vue.use注册Vuex，此后，整个Vue实例上都可以this.xxx来调用Vuex的相关方法了 // 2.注册 Vue.use(Vuex); 实例化仓库结构 实例化Vuex.Store生成一个仓库实例（一般命名为：store） 实例化的时候，需要传入仓库的数据结构对象 // 3.实例化仓库结构 const store = new Vuex.Store({ state:{}, // 源数据管理 getters:{}, // 计算数据管理（类似于组件中的计算属性computed） mutations:{}, // 同步修改源数据的方法 actions:{}, // 异步修改源数据的方法 modules:{} // 模块（每一个模块都包含完整的state、getters、mutations、actions、modules） }) state: 源数据管理 getters: 计算数据管理（类似于组件中的计算属性computed） mutations: 同步修改源数据的方法 actions: 异步修改源数据的方法 modules: 模块（每一个模块都包含完整的state、getters、mutations、actions、modules） state—源数据 请注意！ state里面的数据只能由mutations里面的方法来更新。 state中定义的是仓库里的初始数据，组件内state的获取方式主要有以下几种： 定义 state:{ string:&#39;一路向北&#39;, number:999, boolean:&#39;true&#39;, ... }, 在【计算属性】中直接通过$store来访问this.$store.state.xxx test(){ return this.$store.state.test } 通过vuex提供的【mapState】插件来批量访问: mapState([&#39;xxx&#39;])【推荐！】 import { mapState } from &#39;vuex&#39; ...mapState([&#39;test&#39;]) Tips: state的数据在组件内，都是放在计算属性中获取的 getters—计算数据 拿到state中的源数据去计算一个新的数据，一旦state源数据发生改变，getters中的数据会重新计算 getters中计算数据的默认参数：state 初级语法：（必须是函数） getters:{ newData:state=&gt;{ return 计算得到的新数据 } } getters中计算数据还可以传第二个参数：getters(可以访问当前仓库整个getters，也就是可以借助其他getters计算数据来参与当前数据的计算) 进阶语法：（必须是函数） getters:{ newNum:(state,getters)=&gt;{ //使用getters参数借助newData的数据来计算newNum let result = state.num + getters.newData return result } } 组建中获取getters内的数据 getters中的数据也都是放到computed计算属性中获取！ 直接this.$store.getters.xxx获取对应的getters this.$store.getters.newData 借助mapGetters来获取对应的getters import { mapGetters } from &#39;vuex&#39; ...mapGetters([&#39;newData&#39;]) Tips: getters的数据在组件内，也是放在计算属性中获取的 mutations—同步修改源数据 请注意！ mutations内的方法只能够修改state内的数据。 定义 mutations:{ changeString(state,payload){ state.string = payload } }, mutations中的方法不能直接使用！ mutations中定了同步修改state 的方法，在组建中调用的时候，可以这样： 直接通过$store.commit()提交调用//不传参调用 this.$store.commit(&#39;changeTest&#39;) //传参调用 this.$store.commit(&#39;changeTest&#39;,&#39;新的参数&#39;) //对象提交调用 this.$store.commit({ type:&#39;changeTest&#39;, newValue: &#39;新的参数值&#39; }) /* 对象调用的时候，mutations里面的方法，payload参数不再是直接传递的参数，需要payload.newValue来获取你传递的参数 */ 在methods中借助mapMutations插件，将你想要的的方法获取出来作为methods的方法【香】//引入mapMutations import { mapState,mapMutations } from &#39;vuex&#39; //在methods内获取对应mutation方法 methods:{ // 获取仓库的所有方法 ...mapMutations([&#39;changeTest&#39;]), } //在想要使用方法的地方直接this调用传参即可 mounted(){ this.changeTest(&#39;新的参数值&#39;) } actions——异步修改源数据 actions在什么场景会用到？ 当某一个异步操作的结果下一步立即操作仓库的时候，最好使用actions actions内部只做异步操作，改变仓库源数据依然是mutations内的方法来完成（借由commit来执行调用） 声明语法： actions: { increment (context,payload&lt;额外参数&gt;) { // 打印context，看看内部有什么 context.commit(&#39;increment&#39;) } } 上方代码中，我们打印context后，可以得到{commit, dispatch getters, state, rootState,rootGetters}，由此可知：actions方法中的context包含了当前仓库或module内部全部属性资源访问的途径（除了module） 调用语法： // store实例调用 this.$store.dispatch(action名，参数) // 基于mapActions调用 import { mapActions } from &#39;vuex&#39; { methods：{ ...mapActions([action名]) }, created(){ this.action名(参数) } } modules—模块化管理仓库 modules在仓库中的作用极其大！使用store却不使用modules，我劝你别用！ modules本身包含了仓库五大属性，多个modules在仓库实例的时候一起注册，就可以在项目中使用了 示例： const store = new Vuex.Store({ modules:{ moduleA, moduleB } }) 但是，虽然解耦了module，可却无法在多个module中使用相同的名字来定义state和getters，怎么办？ 请一定注意：namespaced：true 使用仓库却不使用module，我劝你别用；使用module却不使用namespaced，我还是劝你别用！ 使用命名空间后 使用了命名空间后，获取state，getters，mutations，actions的方式就会发生改变 state和getters 原本获取state和getters的方式是： ...mapState([&#39;变量1&#39;,&#39;变量2&#39;]) ...mapGetters([&#39;计算数据1&#39;,&#39;计算数据2&#39;]) 现在有了命名空间，我们需要先声明获取数据的模块： ...mapState(&#39;movies&lt;模块名&gt;&#39;,[&#39;变量1&#39;,&#39;变量2&#39;]) ...mapGetters(&#39;movies&lt;模块名&gt;&#39;,[&#39;计算数据1&#39;,&#39;计算数据2&#39;]) mutations和actions 对于mutations和actions，调用的方式变成如下： ...mapActions(&#39;movies&lt;模块名&gt;&#39;,[&#39;action1&#39;,&#39;action2&#39;]) ...mapMutations(&#39;movies&lt;模块名&gt;&#39;,[&#39;mutation1&#39;,&#39;mutation2&#39;]) 单独调用变成了： //调用action this.$store.dispatch(&#39;movies/initMovieList&#39;) //调用mutations this.$store.commit(&#39;movies/dealMovieList&#39;)","categories":[],"tags":[],"keywords":[]},{"title":"ElementUI","slug":"ElementUI的认识与了解","date":"2021-07-20T07:20:43.000Z","updated":"2021-07-26T17:10:09.526Z","comments":true,"path":"2021/07/20/ElementUI的认识与了解/","link":"","permalink":"/2021/07/20/ElementUI的认识与了解/","excerpt":"","text":"ElementUI使用//在 main.js 中写入以下内容： import ElementUI from &#39;element-ui&#39;; import &#39;element-ui/lib/theme-chalk/index.css&#39;; Vue.use(ElementUI); 具体参照官网快速上手 全局配置 在引入 Element 时，可以传入一个全局配置对象。该对象目前支持 size 与 zIndex 字段。size 用于改变组件的默认尺寸，zIndex 设置弹框的初始 z-index（默认值：2000）。 import Vue from &#39;vue&#39;; import Element from &#39;element-ui&#39;; Vue.use(Element, { size: &#39;small&#39;, zIndex: 3000 }); 注意 element-ui的颜色设计语言有必要记忆 danger — 危险 — 红色 success — 成功 — 绿色 primary — 操作 — 蓝色 info — 信息 — 灰色 warning — 警告 — 橘黄色 布局 使用elementUI中的container布局容器组件，来实现管理系统架构布局 el-container 最大的布局容器，后续的容器都需要使用container包裹才能实现合理布局效果 el-container内部如果含有header或者footer容器的时候为——垂直布局，否则为——水平布局 el-header 头部栏布局容器 el-aside 侧边栏布局容器 el-main 主体内容布局容器 el-footer 底部布局容器 侧边栏 aside &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt;Aside&lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-main&gt;Main&lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; 图片引用 图片引用可以使用三种方式： &lt;template&gt; &lt;!-- 基于img标签实现 --&gt; &lt;img src=&quot;~@/assets/imgs/logo.png&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt; &lt;!-- 基于webpack模块引用语法实现，使用commonJS规范引入图片资源 --&gt; &lt;el-image :src=&quot;require(&#39;@/assets/imgs/logo.png&#39;)&quot;&gt;&lt;/el-image&gt; &lt;!-- 先引入图片，存放到data中定义的数据，再到template中使用 --&gt; &lt;el-image :src=&quot;img&quot;&gt;&lt;/el-image&gt; &lt;/template&gt; el-form表单 el-form表单基本语法代码： el-form 最外层form主体 el-form-item 内部表单项，所有的表单组件都写在表单项标签内 axios封装处理（拦截器） 首先需要配置一个index.js文件，内部对axios做一个预处理： 创建axios实例——axios.create({options配置}) 有时候一个管理系统项目中可能会遇到：多个请求地址、多种请求体 创建axios实例，可以让我们应对多种请求场景 配置axios的拦截器 有的时候你的请求需要提前做一些预操作，比如：post请求某些情况下需要将请求数据进行转义 如果说，后端要求的请求数据参数为x-www-form-urlencoded类型的时候，往往前端需要使用vue/cli内置的依赖——Qs来帮助我们实现参数转义 请求拦截器 axios.interceptors.request.use(config=&gt;{},error=&gt;{}) 回调中，config必须return，否则报错 error，可以使用Promise.reject返回，便于捕获。return Promise.reject(error) 请求拦截器中可以得到本次请求几乎全部相关信息 响应拦截器 axios.interceptors.responese.use(config=&gt;{},error=&gt;{}) 回调中，config必须return，否则报错！ error，可以使用Promise.reject返回，同request拦截器 响应拦截器可以得到本次请求几乎全部响应信息 拦截器存在的意义 所有xiaos请求，在发送request之前或者得到response之前，都可以对相关信息进行预处理 比如发送前对post请求进行序列化查询字符串转义 比如得到响应前，对response的响应状态进行统一处理，比如500则全局处理服务端报错 el-form表单验证 el-form表单验证分两大体系：elementui基本验证和自定义校验但是，el-form表单验证前的操作统一遵循以下原则： 关联——必须为el-form设置【:model】属性 将表单对象赋给:model，此后，表单对象内所有的字段就可以和当前表单关联起来，便于后续使用表单项去映射对应字段 规则——必须为el-form设置【:rules】属性 :rules属性主要设置表单所有字段的验证规则，所以rules中的字段必须和表单对象中的字段保持一致 实例——【必须】为el-form设置【 ref 】属性 ref可以帮助我们获得表单组件的实例，从而调用表单组件的全局校验方法 映射——必须为el-form-item设置prop属性，且属性值为字段名 由于前面:model将表单对象和表单关联起来，此时，只需要通过设置el-form-item的prop即可实现表单项和字段的映射关系 表单rules规则书写语法：{ rules:{ account:[ { //常规校验规则定义 required:true, //是否必填 message:&#39;请输入账号&#39;， //提示信息 trigger:&#39;blur&#39; //触发器，一般指原生事件 } ] } } 如果要实现自定义校验的话，我们需要使用校验规则内一个叫做validator的属性： 先定义一个函数，其参数有： rules——当前字段校验规则 value——当前字段收集的值 callback——是否对当前校验放行 如果校验不通过则callback(new Error(错误信息通知)) 如果校验通过则直接放行callback() 在新的校验规则中将自定义校验方法赋给validator属性 以上全部概念，其实都是从element-ui官方文档上得出的经验，它或许能在某些程度上帮到你，但更希望你在以后的工作中，若是form相关业务无法处理的时候，请务必回归官方文档，仔细查阅示例+配置文档，你会得到很多收获。一个小时的研究，可以支撑你未来五年左右相关问题开发 mixin混入 vue为我们提供了一个api叫做mixin，这个api可以帮助我们将组件内部的script代码解耦出去。 mixin书写格式和组件实例书写格式一模一样 mixin在组件实例中使用mixins属性来注册 //引入 import validateMixin from &quot;./mixins/validateMixin&quot;; // mixins: [validateMixin], mixin内部定义的属性、方法如果与组件内的冲突了，以组件内为准 mixin内生命周期和组件内冲突了，则合并在一起，一块儿执行 知识点回顾es6的模块规范 es6模块规范主要需要大家关注两个关键词：export和import export主要用于暴露声明（块） export主要用于暴露声明和块，代码演示如下： // 暴露声明：var、let、const、function export var a = 10 // 暴露块 let b = 20 export { b } 同时，export还支持暴露默认块 // 默认暴露 let c = 30 export default c 另外，export在暴露的时候还支持别名 // 暴露块 let b = 20 // 为暴露的变量起别名 export { b as numB } 那么引入的时候，就必须引入别名了 import主要用于引入块 如果是暴露的声明或者块，则需要解构引入。 // 引入a import { a } from &#39;./module1.js&#39; console.log(a) // 引入b import { b } from &#39;./module1.js&#39; console.log(b) 如果是暴露的默认块，则直接引入即可 // 引入c import c from &#39;./module1.js&#39; console.log(c) 引入的时候，也可以为变量起一个别名 // 引入别名 import { a as newA } from &#39;./module1.js&#39; console.log(newA) // 引入默认块并起别名 import * as newC from &#39;./module1.js&#39; console.log(newC) 路由守卫 路由前置守卫beforeEach的作用是在路由跳转前获得本次跳转相关信息，接受一个回调函数，回调函数有三个参数： to 目标路由对象 from 起始路由对象 next 若不希望跳转到目标路由，则可以使用next(path)来重定向 若放行，则直接next() 访问修饰器 作用：访问修饰符可以让我们实现安全、可控的内部变量暴露操作： get访问修饰符 必须是修饰函数 必须return set修改修饰符 必须是修饰函数 必须传值 $nextTickel-form更多体现label 在el-form-item表单项标签上设置label，可以让表单项具备标题 label-width 如果不设置label-width，那么垂直排列的表单会呈现表单项和表单组件一上一下的布局形态，设置label-width以后，表单项和表单组件会强制保持一行 inline 为el-form表单主体标签设置inline属性为true，可以实现表单水平排列布局 el-table 书写el-table需要具备以下条件： el-table 表格体 el-table必须传入一个:data属性 data属性接收一个对象数组格式的数据 el-table-column 表格列 el-table-column使用prop来映射对象中的字段 el-table-column通过label来设置表头 vuex中的module 在vuex中，如果业务板块较多，且复杂的时候。我们往往会使用module来协助vuex仓库的解耦。 使用module需要注意以下几点： 创建对应业务板块的module文件 module文件结构其实就是一个独立的vuex对象结构 module内定义state的语法与根仓库state语法有区别 语法结构为： { state(){ return { } } } module最好搭配命名空间使用 为每一个module设置namespaced属性，为true 最终module需要引入到store配置页面，然后传入到storeObj对象的modules中去注册 token 项目中某些接口需要token来进行接口鉴权，所以我们往往会在请求拦截器中获取本地缓存的token，并将其付给headers请求头： // 获取本地token let token = storage.token // 将token放到请求头上 config.headers[&#39;Authorization&#39;] = token 表格自定义渲染 前面使用表格进行了字段映射，此处我们需要实现表格内容自定义渲染，需要注意以下事项： 表格自定义渲染，本质上其实是通过作用域插槽来获得表格组件内的数据 请求类型（面试高频） 常用符合restFullApi规范的请求方法有： get 查询资源操作 有缓存机制，第一次请求后会有服务缓存，后续刷新其实是从缓存中获取内容 post 新增资源操作 请求会叠加，多次post会新增多条数据 put 更新资源操作 请求不会叠加，多次put，只会执行最后一次操作 delete 删除资源操作 没有缓存机制，传参方式和get一致 v-model语法糖原理 v-model语法在vue原生生态中其实仅支持原生表单html元素的双向绑定。但是基于自定义事件和model属性，我们可以实现自己的v-model双向绑定组件。 v-model语法糖的书写语法主要需要注意： 一进 通过model属性指定一个prop，用于接收外界传递的数据 在props中定义一个model指定的prop属性 一出 通过model属性【指定】一个event事件名，用于将内部数据传递到外界 在合适的时机，触发model指定的事件名，将内部数据发送到外界 vue实例的data之谜 vue实例中的data方法常常会被问到以下两个问题： data为什么是一个方法（函数） data中的数据后续手动添加为什么不再与视图双向绑定了？ data为什么是一个方法（函数） vue的组件都是VueComponent的实例对象，内部数据如果直接使用对象来定义的话，基于引用类型特性，会发生多个组件实例公用一份数据地址的情况。使用函数返回的方式，可以保证每一个组件的数据独立 data中的数据后续手动添加为什么不再与视图双向绑定了？ vue框架原理中，一旦data数据返回对象之后，vue内部会遍历这个对象，对每一个属性进行监听，一旦组件初始化完成，这个监听过程也就结束了。所以后续添加的数据不会被监听了 上面第二个问题，如何解决呢？ vue官方提供了一个api——$set，它可以帮助我们手动监听新增的数据。 vm.$set(obj,key,value) wangeditor 使用wangeditor来实现富文本双向绑定组件，我们的目标有以下几个： 安装 npm 安装 npm i wangeditor --save import E from &#39;wangeditor&#39; mouted () { const editor = new E(&#39;#div1&#39;) // 或者 const editor = new E( document.getElementById(&#39;div1&#39;) ) editor.create() } 初始化 参考官网 监听内容变化 参考官网 v-model语法糖 权限管理前端在进行权限管理开发的时候，一定要明白：用户角色决定了这个用户是否可以访问该功能 $route.meta 在vue的路由数据对象中有一个meta属性，这个属性可以为路由对象添加元信息 v-for和v-if v-for和v-if不能在同一个节点上使用，因为v-for权重大于v-if，那么每一次循环都会同时执行一次判断，造成性能浪费，合理的做法是在v-for作用域内，使用template来进行v-if判断。 addRoute addRoute可以帮助我们动态的为router实例添加新的路由规则，从而使得路由得以动态更新。 往往在实现路由权限的时候，我们会遵循以下原则： 先组织一个默认的静态路由数组 静态路由其实指的是所有角色均可访问，无需鉴权的路由 获取本地角色，通过角色来过滤筛选动态路由 筛选完的路由依次追加到最开始的router中 项目跨域问题何为跨域？跨域针对谁？ 跨域只在浏览器平台上存在 跨域是浏览器本身的特性 跨域如何产生？ 浏览器针对网站请求有同源策略限制 何为同源策略？ 协议一致 ip一致 端口一致 以上都保持一致视为同源。往往同源策略出现在ajax请求中，要求客户端请求所在位置的【协议】、【ip】、【端口】和服务端完全一致 才可以请求成功 前端vue开发的时候如果出现跨域，那么可以在项目【根目录】内创建一个vue.config.js文件，用于配置vue-cli脚手架，达到修改默认项目特性的目的。 要想实现跨域，我们需要配置： devServer 该配置用于设置本地localhost：8080 proxy 给配置用于设置本地代理（推荐百度） 此时配置好代理以后所有接口都可以请求通过。但是——本地img图片地址拼接怎么办？！ 请记住，html标签的src并不被同源策略限制。所以以前没有脚手架的时候，我们会利用src属性进行跨域请求，这种方式我们成为jsonp跨域解决方案（强烈推荐百度） 美化项目滚动条 在element-ui内实际上有一个隐藏组件——el-scrollbar 这个组件是一个美化的滚动条，element-ui官网、el-select等等都在使用，我们在注册过ElementUI基类之后就能直接使用了 使用滚动条需要注意： el-scrollbar包裹需要设置滚动的内容 el-scrollbar需要设置一个高度 el-scrollbar__wrap需要设置： 设置overflow-x：hidden 由于样式作用域，我们直接设置无法起效，需要深度选择器来实现样式应用 /deep/ >>> ::v-deep 环境变量 定义：环境变量是vue-cli提供的一种全局设置的机制，它通过node.env全局对象来实现数据共享。 一般环境变量的使用必须同时具备以下条件： 必须具备一个.env打头的文件，并且务必在根目录创建。如：.env.development就代表开发环境 vue-cli默认给了我们三个环境变量：development，production，test 我们还可以定义自己的环境变量文件名，比如在debug阶段，你可能需要创建一个.env.debug的环境变量文件 请务必注意！你的环境变量第二个文件名就是当前启动模式名称 该文件内部变量声明必须全大写（规范）,并且命名方式有两种： 第一种：纯大写全称，比如：BASE_URL = http://www.localhost:8080 该命名的变量只能在vue.config.js内使用 第二种：VUE_APP_前缀的名称，比如：VUE_APP_UPLOAD_URL = http://localhost:5000/upload/img/goods 该命名的变量只能在项目客户侧js代码中使用（如：router.js, vuex.js, xxx.vue的script，axios内） 获取环境变量文件内的变量语法： process.env.变量名 设置好环境变量后，若你创建的是非test | production | development这三个默认模式以外的环境变量的话。必须修改启动脚本： &quot;debug&quot;: &quot;vue-cli-service serve --mode debug&quot;, --mode debug中的debug其实就是你环境变量第二个文件名（.env.debug） 项目基本准备项目开发+生产依赖 vue vue-router vuex axios elementUI less less-loader 目录结构 assets 存放静态资源（图片，字体等等） components 存放全局公共组件 api 所有接口方法 views 存放业务页面 router 路由管理目录 store vuex数据仓库 utils 工具类目录","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"ElementUI的使用","slug":"ElementUI的使用","permalink":"/tags/ElementUI的使用/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"MVC、MVVM","slug":"MVC与MVVM的简单了解","date":"2021-07-11T23:20:55.000Z","updated":"2021-07-25T19:28:24.155Z","comments":true,"path":"2021/07/12/MVC与MVVM的简单了解/","link":"","permalink":"/2021/07/12/MVC与MVVM的简单了解/","excerpt":"","text":"MVC&amp;MVVMMVC 在软件工程体系中，最重要的是易用、复用、解耦。因为大型应用开发过程中会有很多多变的需求，为了应对这些需求，有高手发明了一种软件开发的架构思想——MVC MVC可以称之为软件架构鼻祖，它将软件应用氛围三个层面： M——Model 数据层 往往一个软件应用的核心功能都是数据驱动的 V——View 视图层 将数据渲染到应用界面形成用户可以看到的界面视图 C——Controller 控制层 控制数据如何驱动视图的过程 案列Html js MVVM MVVM本质上是对MVC的升级，MVC实现了数据、视图、控制器的分离，但是控制器逻辑还是需要我们手动编写，MVVM的出现，让我们脱离了控制器的逻辑编写过程，让架构模式变得更简单智能。 MVVM将应用分成了三个方面： M——Model 数据层 用于应用的数据模型，驱动应用 V——View 视图层 将数据渲染到应用界面 VM——ViewModel 数据视图层 将视图和数据关联起来，数据和视图有一个发生了改变，那么另一个也会发生改变 MVVM架构中VM不需要开发人员去维护，它会自动帮助我们将数据和视图双向绑定起来 MVVM架构中Object.defineProperty是一个很重要的概念 Object.defineProperty 该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 其主要参数为： obj 被配置的对象 property 对象上需要配置的属性 descriptor 描述器 描述器主要用于对属性进行配置 重点我们需要学习描述器，descriptor。它可以对属性进行配置描述，通过以下几个配置项： 1.configureable 当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 { /* configurable：设置属性是否可配 默认值 false 当configurable为false的时候，该属性不可重新设置configurable也不可删除 */ const obj = { name: &#39;张三&#39; } Object.defineProperty(obj, &#39;name&#39;, { configurable: false }) // Object.defineProperty(obj, &#39;name&#39;, { // configurable: true // }) delete obj.name; // console.log(obj) } 2.enumerable 当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。默认为 false。 { /* enumerable：配置该属性是否可枚举 默认值 false */ const obj = { name: &#39;张三&#39;, age: 20 } Object.defineProperty(obj, &#39;name&#39;, { enumerable: false }) // for (let key in obj) { // console.log(key) // } } 3.value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。**默认为 undefined。 { /* value：配置属性值 默认值为undefined */ const obj = { } Object.defineProperty(obj, &#39;name&#39;, { value: &#39;李四&#39; }) // console.log(obj) obj.name = &#39;王五&#39; // console.log(obj) } 4.writable 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被[赋值运算符 (en-US)改变。默认为 false。 { /* writable: 配置该属性是否可写 默认值为false */ const obj = { name: &#39;张三&#39; } Object.defineProperty(obj, &#39;name&#39;, { writable: false }) obj.name = &#39;李四&#39; // console.log(obj) } 5&amp;6.get、set 属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。默认为 [undefined]。 { /* 描述器内属性有两组类型不能共存： - 数据描述器 - value - writable - 存取描述器 - get - set */ const obj = { name: &#39;张三&#39; } // 此处，将数据保存到变量中非常重要，一定要这么做！ let nameVal = obj.name Object.defineProperty(obj, &#39;name&#39;, { get() { console.log(&#39;你正在访问name&#39;) return nameVal }, set(val) { console.log(&#39;你正在修改name&#39;) nameVal = val } }) // console.log(obj.name); // obj.name = &#39;李四&#39; // console.log(obj.name); } 批量修改一个对象的所有属性，设置get和set { /* 如何批量修改一个对象的所有属性，设置get和set */ const obj = { name: &#39;张三&#39;, age: 20 } for (let key in obj) { // 将每一个属性值存放到变量中 let keyVal = obj[key] Object.defineProperty(obj, key, { get() { console.log(`你正在访问${key}`) return keyVal }, set(val) { console.log(`你正在修改${key}`) keyVal = val } }) } obj.name = &#39;李四&#39;; obj.age }","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"MVC、MVVM","slug":"MVC、MVVM","permalink":"/tags/MVC、MVVM/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"express的简单搭建","slug":"express的简单搭建","date":"2021-07-10T08:41:55.000Z","updated":"2021-07-25T19:26:28.915Z","comments":true,"path":"2021/07/10/express的简单搭建/","link":"","permalink":"/2021/07/10/express的简单搭建/","excerpt":"","text":"express1 安装【理解】1.1 概念： 概念：express是一个node的框架，用于快速搭建后端服务器。 安装==脚手架==： express-generator PATH路径配置path路径： 得到yarn的bin路径:yarn global bin 找到yarn的bin目录，复制路径。我的电脑-&gt;属性-&gt;高级设置-&gt;环境变量-&gt;系统变量-&gt;Path-&gt;把yarn的bin目录路径添加进去。 1.2 安装步骤 全局安装 express-generator【1】 yarn global add express-generator 或 npm i express-generator -g express --version // 测试 如果看到版本号 证明安装成功 搭建项目【2】 express 项目名 cd进入项目目录，安装依赖【3】 yarn 或 npm i 启动项目【4】 yarn start 或 npm run start 访问服务：http://127.0.0.1:3000 1.3 修改启动方式 手动监听端口【app.js 40行】 app.listen(端口号, () =&gt; { console.log(&#39;提示信息&#39;) }) 1.4 自动重启 安装nodemon yarn global add nodemon 或 npm i nodemon -g nodemon --version // 测试 修改启动方式 【package.json】 &quot;scripts&quot;: { &quot;start&quot;: &quot;nodemon app&quot; }, 2 目录详解【理解】 见【图形笔记】 3 路由【理解】3.1 概念： 后端路由： 接收前端发送的请求，响应数据给前端。 路由代码： var express = require(&#39;express&#39;); // 引入express模块 var router = express.Router(); // 调用方法 生成一个路由对象 /** 使用 router对象 接收请求 响应数据 **/ module.exports = router; // 把路由对象暴露出去 3.2 路由的基本使用 接收get请求 和 接收 post请求 var express = require(&#39;express&#39;); // 引入express模块 var router = express.Router(); // 调用方法 生成一个路由对象 /** 使用 router对象 接收请求 响应数据 **/ router.get(&#39;/路径&#39;, (req, res) =&gt; { res.send(&#39;数据&#39;) // 响应数据给前端 }) router.post(&#39;/路径&#39;, (req, res) =&gt; { res.send(&#39;数据&#39;) // 响应数据给前端 }) module.exports = router; // 把路由对象暴露出去 3.3 拆分路由 在routes中创建一个路由js文件 【有头有尾】 vips.js 在app.js中引入分配 var vipsRouter = require(&#39;./routes/vips&#39;); // 引入路由 app.use(&#39;/vips&#39;, vipsRouter); // 分配路由 可以正常使用 3.4 两个对象 res： response,响应对象，主要负责发送数据给前端。 方法： res.send(); // 发送数据给前端 万能方法 // 不能发送数字，发送数字，它会认为是http状态码。报错 req： request,请求对象，主要负责接收前端的参数。 方法： // 1. 接收get方式传递的参数 req.query.参数名 // 2. 接收post方式传递的参数 req.body.参数名 ## 4 后端准备【了解】 建库建表【1】 写nodejs代码，连接数据库 // 1. 下一个模块【node要操作数据库 就需要这个模块】 yarn add mysql/npm i mysql // 2. 创建一个连接数据库的js文件【里面写连接代码】。 const mysql = require(&#39;mysql&#39;) // 引入模块 const conn = mysql.createConnection({ // 创建一个连接对象 host: &#39;localhost&#39;, // 要连接的数据库的地址 user: &#39;root&#39;, // 要连接的数据库的账号 password: &#39;root&#39;, // 密码 database: &#39;xxxx&#39; // 要连接的数据库的名字 }) conn.connect(); // 执行连接方法 module.exports = conn; // 把连接对象暴露出去 [express 允许跨域访问]//设置允许跨域访问该服务. app.all(&#39;*&#39;, function (req, res, next) { res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type&#39;); res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;*&#39;); res.header(&#39;Content-Type&#39;, &#39;application/json;charset=utf-8&#39;); next(); }); 下载插件cors yarn add cors -S const cors=require(&quot;cors&quot;) app.use(cors())","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"express","slug":"express","permalink":"/tags/express/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"TypeScript","slug":"TypeScript","date":"2021-06-29T02:25:33.000Z","updated":"2021-07-27T10:13:36.771Z","comments":true,"path":"2021/06/29/TypeScript/","link":"","permalink":"/2021/06/29/TypeScript/","excerpt":"","text":"Typescript简介 Typescript（以下简称TS），是一个JavaScript的超集，主要特点为： 兼容所有JS语法 提供了新的特性，以达到静态语言的规范，由此达到类似于java，c#这类语言一般自带面向对象规范 TS提供类型检查机制 TS和vsCode都是微软家开发的，所以用什么编辑器，大家心里应该有数 安装TS 学习TS，首先，请先安装TS 安装前，请打开cmd窗口，输入命令：tsc --version,如果出现版本号则本机已经全局安装了TS，否则，你需要执行安装命令： npm i typescript -g yarn global add typescript 创建目录 安装完成以后，我们创建一个目录，用于TS项目开发——ts-demo 初始化项目 进入你的目录内，打开cmd，运行一条命令：tsc --init，此后回到目录，可以发现，目录内多了一个名为tsconfig.json，这个文件主要用于对ts编译进行配置，那么我们前期需要配置的项目有： rootDir——ts源文件目录 你书写的ts就在这个目录内 该配置主要告知编译器，你写的ts在哪个目录 此处我们配置为’./ts’目录 outDir——编译后js文件输出的目录 ts书写后需要编译为js才能 在浏览器运行，该配置主要用于编译器将编译后的js存放在指定目录 此处我们配置为’./js’目录 module——指定该项目支持的模块规范 配置为es2015，用于支持es6语法 书写并编译TS 在ts目录内书写一个文件——01.test.ts 内部书写以下代码： let str:string = &#39;hello world&#39; console.log(str) TS需要编译后才能运行，你有三种方式来执行编译： 在终端（或cmd）打开当前ts文件所在目录，运行tsc 01.test.ts 该方式为手动编译，会在当前文件所在目录直接生成一个js 在终端（或cmd）打开当前ts文件所在目录，运行tsc 该方式会遵循tsconfig.json配置的规则来进行编译 在终端（或cmd）打开当前ts文件所在目录，运行tsc -W或者tsc --watch 该方式为监听编译模式，ts文件一旦编辑并保存则自动编译 TS基础类型约束 TS最大的亮点在于对类型约束非常严格，而基本的类型约束又要分以下两种： 基本类型 通用语法为：let 变量名:类型 = 值 字符串let str:string = &#39;hello world&#39; 数字let num:number = 10 布尔let bool:boolean = true nulllet nul:null = null undefinedlet udf:undefined = undefined symbol symbol在ts中为一种单独特殊类型，此处不做介绍 一旦变量声明了类型就不能再给其他类型值了,正常情况下，ts项目中的tsconfig.json默认配置了严格null类型检查，即null不能和undefined相同对待,但是，ts非严格模式下，会认为null和undefined都代表什么都没有，所以两者可以相互复制,只需要更改tsconfig中的strictNullChecks为false即可,但是不建议这么做，毕竟ts的目的就是保持代码严谨性 类型断言 有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 尖括号语法let someValue: any = &quot;this is a string&quot;; let strLength: number = (&lt;string&gt;someValue).length; as语法let someValue: any = &quot;this is a string&quot;; let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。 TS特有类型 TS还提供了几个特有类型，用于支持TS独有的语法 any any类型代表什么类型都可以，一旦一个数据被定义为any类型的时候，这个数据就可以接受任何类型了。any是ts中的顶级类型，包含了所有ts可用类型。 在TS编译器机制内，any其实是告知了编译器，当前数据不需要类型检查 let anySth:any = &#39;hello world&#39; anySth = 10 void 最常见于函数没有返回值的时候。 void代表什么都没有，一般情况下，在函数返回值中使用。 当一个函数没有返回值的时候，可以使用void和any去约束返回值类型 function doSth():void{ console.log(&#39;只打印，不返回&#39;) } unknown 作用和表现与any非常类似，和any一样，同为ts顶级类型 更推荐unknown，因为更安全 unknown必须在使用的时候显式明确当前变量类型 let nkw: unknown = 10 nkw = &#39;hello world&#39; const nums: unknown = [1, 2, 3, 4, 5] // 使用断言来明确nums的类型 console.log((nums as number[]).length) 元组 元祖和数组比较类似，但是，元祖有以下特点： 你提前知道该数组有几个元素 你提前直到该数组每个元素的类型 let tupleS:[string,number,boolean] = [&#39;hello&#39;,10,true] 引用类型 TS的类型约束重点并非体现在基本类型约束，基本类型语法可以理解为声明类型约束，引用类型约束其实是基于一个叫做【结构子类型】的约束规范。 TS对于数组、对象的类型约束都是基于【结构子类型】规则来实现的！ 常规声明中，我们需要在声明符中严格体现当前对象的结构 数组 数组的约束，有三种方式（基本）： 类型符+[]let arr:number[] = [1,2,3] 泛型let arr:Array&lt;number&gt; = [1,2,3] 联合类型协助声明数组let arr:(string | number | boolean)[] = [&#39;a&#39;,1,true] let arr:Array&lt;string | number | boolean&gt;= [&#39;a&#39;,1,true] 对象 对象的约束，请确保你的对象结构被提前定义。这样后续代码才可以顺利获取并操作对象中的成员 function dealObj(arg:{name:string,age:number}):string{ return arg.name } dealObj({name:&#39;张三&#39;,age:20}) 但是，实际TS开发中，我们更多使用的是接口来约束对象，而不是手写对象结构 接口 前面描述了数组和对象的类型约束，但都不是最常用的方式，特别是对象，在实际开发中我们对对象的使用往往需要借助接口来实现。 何为接口？ 最前面说过，TS的类型检测是基于【结构子类型】来实现的，即TS对于数据不仅仅是基本类型约束，还有结构的约束。 对数据的结构及成员类型进行明确约束的规则。 TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 最基本的接口语法：// 定义接口 interface 接口名 { 属性1:类型1; 属性2：类型2; ... } // 使用接口 let obj:接口名 = { 内部属性名和类型要严格遵守接口约束 } 接口选择属性interface StuInfo { name: string; age: number; [key: string]: any } const stuInfo: StuInfo = { name: &#39;张三&#39;, age: 20, address: &#39;重庆&#39; } 接口描述数组interface ArrStr { [index: number]: string } const arrStr: ArrStr = [&#39;c&#39;] 只读属性 readOnly ts中大部分情况下的只读都是使用readOnly修饰符 对象情况： interface OneReadOnly { readonly name: string; age: number } const oneReadOnly: OneReadOnly = { name: &#39;张三&#39;, age: 20 } oneReadOnly.age = 30 // oneReadOnly.name = &#39;李四&#39; 数组情况： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray&lt;number&gt; = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! //可以使用断言重写 a = ro as number[]; readonly vs const 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。 接口可选属性interface MayChooseProp { name: string; age?: number; } const mayChooseProp: MayChooseProp = { name: &#39;张三&#39; } 好处：可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 接口的继承函数 TS中函数相对于JS做了一些简单的新特性，同时又兼容原本ES中的所有函数特点。 TS对函数的约束主要体现在：参数列表+返回值 函数的参数列表必须具备明确的类型约束 返回值也需要有类型约束（可以不用写，TS编译器会通过结果推导出该函数返回值类型），如果TS函数的返回值没有明确return的话，则需要使用void或者any来修饰返回值类型 标准语法： 没有参数： function doSth():void { console.log(&#39;做点什么&#39;) } 有参数function 函数名(参数1:类型，参数2:类型)：返回值类型{ 。。。 } 可选参数function argOptional(arg1: number, arg2?: number): void { // return arg1 + arg2 console.log(arg1, arg2) } //如果arg2是可选参数调用时只传了一个参数，但是返回值类型为number的话得到的结果会是undefined argOptional(10) 默认参数function defaultArgData(arg1: number, arg2: number = 10) { return arg1 + arg2 } defaultArgData(20) 接口定义函数 函数的结构，只体现在参数列表和返回值上 单独函数接口约束 interface Fn { (argument1: number): number } const fn: Fn = function (arg1: number): number { return arg1 + 10 } 接口约束方法interface SomeObj { prop: string; dealProp: (arg: string) =&gt; string } const someObj: SomeObj = { prop: &#39;属性1&#39;, dealProp(arg1: string) { return arg1 } } 泛型 TS中为了实现某些计算过程的复用从而提出了泛型概念，这在以往只有高级语言才具备，比如java。 TS中对数据结构的约束，大大的提升了代码严谨性。但是也带来了额外的情况。 原生JS封装了一个函数，可以根据参数的不同而得到不同结果，这在TS中是不允许的。 为了让TS中的函数拥有多变性和复用性，我们需要泛型来协助。 在讲解泛型之前，我们需要先知道一个新概念——类型变量 何为类型变量？ 一个可变数据参与数据类型的修饰，则为类型变量 // &lt;&gt;代表此处需要传入反省参数——也成为了类型变量 // 基于泛型的思考一定是这样的： /* 我很清楚我在做什么，我也很清楚我要什么！ */ function dealArg&lt;AA&gt;(arg1: AA, arg2: string): any { return arg1 + arg2 } 类比函数来思考泛型： 传统函数，只提供了可变的值参数 泛型，不仅提供值参数，还提供类型参数 泛型函数function dealSth&lt;T&gt;(arg: T): T { console.log(arg) return arg } dealSth&lt;number&gt;(10) 泛型接口interface NewStuInfo&lt;T&gt; { name: string; age: number; mark: T } const newStuInfo1: NewStuInfo&lt;string&gt; = { name: &#39;张三&#39;, age: 20, mark: &#39;这是一个努力的人&#39; } const newStuInfo2: NewStuInfo&lt;number&gt; = { name: &#39;李四&#39;, age: 20, mark: 100 } class类 ES6+中我们学习了class类，在TS中除了兼容ES类语法以外，还提供了部分额外特性 TS针对class提供了以下新特性： 属性类型约束 静态属性 三大修饰符 public 公共属性，哪儿都能访问 默认情况下定义的属性都是公共属性 protected 保护属性，只能当前类和继承类的内部可以访问，实例不行 private 私有属性，只能当前类内部可以访问 两大存取修饰符 get set 只读属性—–readonly 示例class StuClass { static selfName: string = &#39;这是静态属性&#39; name: string age: number address!: string //此处使用非空断言符，可以告知编译器，这个值后续我一定赋值 protected score: number = 100 //保护属性，只能当前类和继承类的内部可以访问，实例不行 private selfInfo: string = &#39;私人信息&#39; //私有属性，只能当前类内部可以访问 constructor(name: string, age: number) { this.name = name; this.age = age; } get selfInfoData() { return this.selfInfo } set selfInfoData(val) { this.selfInfo = val } getName() { return this.name } static getSelfName() { return this.selfName } } class StuInfoClass extends StuClass { showScore() { console.log(this.score) } } const stuClass = new StuClass(&#39;张三&#39;, 20) stuClass.selfInfoData = &#39;新的私人信息&#39; console.log(stuClass.selfInfoData)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"/tags/TypeScript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Vue3.0","slug":"vue3.0","date":"2021-06-28T06:22:19.000Z","updated":"2021-07-25T19:29:06.315Z","comments":true,"path":"2021/06/28/vue3.0/","link":"","permalink":"/2021/06/28/vue3.0/","excerpt":"","text":"vue3.0简介关于启动 这个没什么好说的，启动的时候选择vue3项目即可 编辑器报错 vue3.0现在已经支持了多根节点模板。如果你打开一个.vue文件发现报错：只能拥有一个根节点，那么请检查是否你的项目是作为工作区打开的 vue2.x语法 首先你必须明确的知道，vue3.0依然支持2.x的option—component语法，所以你还是可以使用以前的知识来进行开发 vue3.x新特性 当然，如果依然使用option-component语法来书写组件的话，我们使用vue3.x的优势就会大大降低。一起来看看vue3.x的新特性为我们带来了哪些惊喜？ setup选项 组合api的学习是从setup选项开始的，vue3.x为我们提供了一个新的配置项——setup。 这个选项有以下特点： setup在组件创建之前执行 setup是一个函数 setup函数接受props和context参数 props是组件定义的属性，一旦props被解析，则立即作为组合式api的入口 context——待定 setup中返回的所有内容都可以被组件内其余部分使用（方法，watch，计算属性，生命周期，模板等等） setup存在的意义是什么？ 很简单，setup存在的意义是让同样执行过程的代码组织得更加紧密！ 比如以下需求： 从后端获取一个数据 将数据给到组件内一个变量（误称，本质上是data属性） 点击模板中的一个按钮，改变这个数据 // import { ref } from &quot;vue&quot;; export default { // setup组合式api setup() { //定义一个数据 let numData = 10; // 模拟从后端获取数据 function getData() { setTimeout(() =&gt; { console.log(&quot;更新了&quot;); // 此处做一个console用于观察异步方法是否执行 numData = 30; }, 1000); } // 将数据和异步方法都返回出去，供组件使用 return { numData, getData, }; }, // 在生命周期中调用异步方法，达到更新数据的目的 mounted() { this.getData(); }, }; 上面定义好以后将numData在模板中使用，会发现：模板能正常渲染我们在setup中定义的变量。 另外，控制台的打印告知我们，mounted生命周期内可以正常调用getData方法。 但是！getData异步更新了numData，我们却发现视图并未更新，为什么呢？ ref响应式变量 仔细观察上面setup中的numData，其实这只是在一个函数内声明了一个局部变量，虽然我们将其返回出去，但vue并没有为我们订阅这个数据，所以数据变化的时候，视图并不会变化。 既然如此，我们前面定义的numData也就无法作为组件内的有效数据使用了，怎么办呢？vue3.x为我们提供了一个ref用于使得变量在任何地方都是响应式的。 关于这个ref： 请务必和2.x的ref区分，2.x内的ref主要用于获取dom或者组件实例。3.x也有这个api 这个ref是vue暴露的一个方法，可以使用ref手动订阅一个数据，从此这个数据就是响应式的了 3.x中的ref基于proxy来订阅数据，监听能力比2.x的Object.defineProperty更强悍，能够监听深层次的对象变化 那么我们使用ref来完善上面的功能，弥补缺陷为：更新numData，视图也发生改变 // 引入ref import { ref } from &quot;vue&quot;; export default { // setup组合式api setup() { // 使用ref来定义一个数据 let numData = ref(10); // 观察这个数据 console.log(numData); // 模拟从后端获取数据 function getData() { setTimeout(() =&gt; { console.log(&quot;更新了&quot;); // 此处做一个console用于观察异步方法是否执行 // 使用numData.value来获得数据值，并更新 numData.value += 30; }, 1000); } // 将数据和异步方法都返回出去，供组件使用 return { numData, getData, }; }, // 在生命周期中调用异步方法，达到更新数据的目的 mounted() { this.getData(); }, }; 此时运行代码，我们发现numData发生改变后，视图也发生了改变。 生命周期钩子 再次观察上面的代码，我们发现一个问题，我们在setup内部其实一直都在做一个过程： 定义一个变量 定义一个异步请求方法 通过请求更新变量 其实这是一个完整过程，按道理他们的代码应该紧密组织在一起才可以让我们更好的维护，但现在我们变成了： 定义一个变量 定义一个异步请求方法 将变量和异步请求方法返回出去，变量在模板渲染，异步请求方法在mounted中调用 这里有一个不太合理的代码组织——将异步请求方法在mounted中调用。 既然异步方法是为了更新我们定义的变量，从而更新视图，为什么异步方法需要跑到mounted这么远的一个配置中调用呢？为了解决这个问题，vue为我们提供了注册生命周期的各个方法——on+生命周期名 比如：onMounted、onCreated 这些生命周期方法接受一个回调，一旦组件执行到某个生命周期的时候，会调用这个回调方法 那么继续来改造代码： // 引入ref import { ref, onMounted } from &quot;vue&quot;; export default { // setup组合式api setup() { // 使用ref来定义一个数据 let numData = ref(10); // 观察这个数据 console.log(numData); // 模拟从后端获取数据 function getData() { setTimeout(() =&gt; { console.log(&quot;更新了&quot;); // 此处做一个console用于观察异步方法是否执行 // 使用numData.value来获得数据值，并更新 numData.value += 30; }, 1000); } // 注册mounted生命周期 onMounted(getData); // 将数据和异步方法都返回出去，供组件使用 return { numData, getData, }; }, }; 此时我们的代码中取消了mounted选项，将生命周期放到了setup中注册，代码组织进一步内聚。 watch的独立注册 现在咱们来看一个新的需求： 当numData发生改变的时候，我们需要在控制台打印一个信息 在vue2.0的时候我们可以通过watch来实现这个需求： export default { // setup组合式api setup() { // 使用ref来定义一个数据 let numData = ref(10); // 观察这个数据 console.log(numData); // 模拟从后端获取数据 function getData() { setTimeout(() =&gt; { console.log(&quot;更新了&quot;); // 此处做一个console用于观察异步方法是否执行 // 使用numData.value来获得数据值，并更新 numData.value += 30; }, 1000); } // 注册mounted生命周期 onMounted(getData); // 将数据和异步方法都返回出去，供组件使用 return { numData, getData, }; }, // 使用vue2.x的watch选项来监听numData watch: { numData(newVal, oldVal) { console.log(`新的数据是${newVal},旧的数据是${oldVal}`); }, }, }; 上面我们使用vue2.x的选项来监听numData，这让numData相关逻辑代码又一次被分拆到不同板块中，为后续维护带来阻碍。 vue3.x也提供了一个独立的watch方法，在setup中，我们可以通过这个方法来实现对数据的变化监听： export default { // setup组合式api setup() { // 使用ref来定义一个数据 let numData = ref(10); // 观察这个数据 console.log(numData); // 模拟从后端获取数据 function getData() { setTimeout(() =&gt; { console.log(&quot;更新了&quot;); // 此处做一个console用于观察异步方法是否执行 // 使用numData.value来获得数据值，并更新 numData.value += 30; }, 1000); } // 注册mounted生命周期 onMounted(getData); // 使用watch方法来监听numData watch(numData, (newVal, oldVal) =&gt; { console.log(`新的数据是${newVal},旧的数据是${oldVal}`); }); // 将数据和异步方法都返回出去，供组件使用 return { numData, getData, }; }, }; 现在我们的组件就变成了这样。此时，watch的代码逻辑也和numData紧密结合在一起 独立的computed 在组件开发中，难免我们需要根据源数据来生成新的数据，vue2.x为我们提供了computed选项，那么setup中我们又该如何完成呢？ 其实，在学习watch的时候，我们就已经应该知道了，vue应该也提供了一个computed方法给我们，让我们可以在setup实现计算属性的代码过程 export default { props: { txt: { type: String, }, }, // setup组合式api setup() { // 使用ref来定义一个数据 let numData = ref(10); // 观察这个数据 console.log(numData); // 模拟从后端获取数据 function getData() { setTimeout(() =&gt; { console.log(&quot;更新了&quot;); // 此处做一个console用于观察异步方法是否执行 // 使用numData.value来获得数据值，并更新 numData.value += 30; }, 1000); } // 注册mounted生命周期 onMounted(getData); // 使用watch方法来监听numData watch(numData, (newVal, oldVal) =&gt; { console.log(`新的数据是${newVal},旧的数据是${oldVal}`); }); // 定义一个事件 function doSth() { console.log(&quot;点击按钮&quot;); } // 实现一个计算属性值 const newNumData = computed(() =&gt; `这是计算出来的新属性${numData.value}`); // 将数据和异步方法都返回出去，供组件使用 return { numData, getData, doSth, newNumData, }; }, }; 令人迷惑的props 当我们在使用setup书写组件的时候，可能会遇到这样的情况——我们需要监听某个属性的变化，一旦这个属性改变了则立即执行某些操作。可是按照下面的书写方式我们很可能无法得到想要的结果： app.vue&lt;template&gt; &lt;Cmpt1 :txt=&quot;str&quot; /&gt; &lt;button @click=&quot;changeStr&quot;&gt;改变文本&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import Cmpt1 from &quot;./components/Cmpt1&quot;; export default { components: { Cmpt1, }, data() { return { str: &quot;测试文本&quot;, }; }, methods: { changeStr() { this.str = &quot;新的文本&quot;; }, }, }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; Cmpt1.vue&lt;template&gt; &lt;div&gt; {{ txt }} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { watch } from &quot;@vue/runtime-core&quot;; // 引入ref export default { props: { txt: String, }, setup(props) { // 监听属性txt的变化，一旦发生改变则立即执行回调，打印新的数据 watch(props.txt, (newVal) =&gt; { console.log(newVal); }); }, }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 最终当你点击按钮的时候会发现，watch内的回调并没有执行。 现在我们换个方式：使用toRefs基于props构建一个新的ref对象，此时props中的所有属性都会被订阅，并且toRefs得出的结果和原本的prop并没有关系，这有一个好处： props值负责对属性的定义——语法声明的意义 toRefs通过props生成一份新的ref——用于逻辑运算 所以我们的代码会这样： import { watch, toRefs } from &quot;@vue/runtime-core&quot;; // 引入ref export default { props: { txt: String, }, setup(props) { // 通过toRefs将整个props生成一份新的ref const { txt } = toRefs(props); console.log(txt); // 监听属性txt的变化，一旦发生改变则立即执行回调，打印新的数据 watch(txt, (newVal) =&gt; { console.log(newVal); }); }, }; 颠覆你认知的ref 我们曾经在vue2.x中使用过ref，那么现在在组合api中如何使用ref呢？其实，vue3.x将响应式数据api的ref和2.x的ref合并到了一起，我们只需要： 定义一个value为null的ref 将这个ref返回出去 在模板中使用ref标记组件（元素），值为返回的这个ref变量名 &lt;template&gt; &lt;div&gt; {{ txt }} &lt;p ref=&quot;p1&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, onMounted } from &quot;@vue/runtime-core&quot;; // 引入ref export default { props: { txt: String, }, setup() { // 通过toRefs将整个props生成一份新的ref const p1 = ref(null); onMounted(() =&gt; { console.log(p1.value); //此处打印的就是p标签的dom }); return { p1, // 此处务必将p1导出去，并且在template中使用p1作为ref名 }; }, }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Vue3.0简介","slug":"Vue3-0简介","permalink":"/tags/Vue3-0简介/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Vue2.0","slug":"vue2.0","date":"2021-06-11T01:48:53.000Z","updated":"2021-07-25T19:28:56.909Z","comments":true,"path":"2021/06/11/vue2.0/","link":"","permalink":"/2021/06/11/vue2.0/","excerpt":"","text":"VUEvue的介绍 vue：Vue是一个构建用户界面（UI）的JS库。 vue是一个构建数据驱动的渐进式框架，Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定,视图组件化开发。基于MVVM设计模式书写。 Vue是建立于 Angular和React的基础之上，它保留了Angular和React的优点并添加了自己的独特成分，让框架的使用变得更加简单，这保证了Vue足够的美好来吸引JS开发人员的胃口。 特性 轻量:Vue库的体积非常小的，并且不依赖其他基础库。 数据驱动:对于一些富交互、状态机类似的前端UI界面，数据绑定非常简单、方便。 指令（简化代码）：内置指令统一为(v—*)，也可以自定义指令，通过对应表达值的变化就可以修改对应的DOM。 插件化：Vue.js核心不包含Router、AJAX、表单验证等功能，但是可以非常方便地根据需要加载对应插件。 组件化：组件可以扩展 HTML 元素，封装可重用的代码。允许我们使用小型、自包含和通常可复用的组件构建大型应用 Vue项目环境搭建（安装步骤）1.全局安装yarn global add @vue/cli npm i @vue/cli -g 2.创建项目 vue create 项目名(项目名只能全部小写) ** 选择default 2即可（第一个选项） 3.进入项目 cd 项目名 4.启动服务yarn serve npm run serve 项目目录结构vue中我们常用项目结构如下（部分目录是后续自己创建的）： public 静态文件目录 主要包含index.html文件，和ico图标 public中的index.html就是单页面应用内的唯一那个html文件 src 项目开发主目录 所有vue开发相关内容都在src中 下文会仔细解析 .gitignore git忽略文件配置 babel.config.js babel是一个js的编译器，可以将浏览器不支持的预编译语言编译成浏览器能支持的结果 babel.config.js主要的作用是配置vue项目内的编译 package.json 依赖管理 yarn.lock(小重点) 这个文件的作用是记录yarn安装的所有依赖地址 以后使用yarn安装会首选.lock中的地址 有时候npm服务资源不稳定，就导致原本lock中的地址失效，从而多次yarn也会失败 此时，我们应该，删除.lock文件，再重新yarn一次 vue.config.js vue脚手架配置工具 默认安装的项目并没有这个文件，需要手动创建 主要作用是—— 设置代理 设置编译 配置多页面 配置本地服务 重点！！！ 在vue中我们更多接触的目录是——src src是vue里面最重要的开发目录，我们需要在src中规划我们的开发资源，那么常用的src目录如下： assets 静态文件——css，js，img，font（字体） components 组件 api 业务接口 推荐大家开发规范是： 一个页面的接口就是一个目录 目录内当前接口文件命名xxx.api.js 但，去了单位，还是遵循别人的规范吧 utils 工具类 router 路由 store 数据仓库 plugins 插件 备注：需要安装vetur插件，支持vue代码高亮显示。 组件组件的定义 所谓组件，即封装起来的具有独立功能的UI部件。开发者从功能的角度出发，将UI分成不同的组件，每个组件都独立封装。 组件特点：可重用、可组合、易维护 命名规则：大驼峰 vue组件使用步骤引入 import引入自己定义的组件 注册 使用components属性注册你的组件 使用 将组件标签放到template中使用 上面三步必须严格执行，否则eslint会报错 自定义组件XXX.vue &lt;template&gt; &lt;h1&gt;Hello!&lt;/h1&gt; //HTML &lt;/template&gt; &lt;script&gt; export default { //JS } &lt;/script&gt; &lt;style&gt; //样式 &lt;/style&gt; 使用自定义组件//使用组件，先导入组件，注册到自己组件中，然后就可以像标签一样使用。 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;Hello /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Hello from &#39;./components/Hello.vue&#39; export default { components: { Hello } } &lt;/script&gt; 组件化开发 项目中有公共的部分，就把公共的部分提出来单独做一个组件，哪里要使用就在哪里调用。 语法结构: A.vue B.vue Index.vue &lt;template&gt; &lt;div&gt; &lt;A/&gt; &lt;B/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import A from &#39;xxx/A.vue&#39; import B from &#39;xxx/B.vue&#39; export default { //组件 components:{ A,//A:A B } } &lt;/script&gt; 定义数据 vue定义数据在data中定义，data中的数据可以在组件内部的script中参与计算，也可以在template模板中使用 &lt;template&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { words: &quot;这是定义的数据&quot;, }; }, }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; Mustach模板编译语法 Mustach语法让我们可以将组件内部定义的数据渲染到视图template木板上 &lt;template&gt; &lt;div&gt;{{ words }}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { words: &quot;这是我自己创建的组件&quot;, }; }, }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; //案例 &lt;template&gt; &lt;div&gt; &lt;Header /&gt; &lt;div&gt; &lt;p&gt;{{ city }}&lt;/p&gt; &lt;p&gt;{{ msg }}&lt;/p&gt; &lt;h1&gt;{{ sex === 0 ? \"男\" : \"女\" }}&lt;/h1&gt; &lt;button @click=&quot;changeCity&quot;&gt;定位&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Header from &quot;./components/Header&quot;; export default { components: { Header, }, data() { return { city: &quot;重庆&quot;, msg: &quot;用户名或密码错误&quot;, sex: 1, }; }, methods: { changeCity() { this.city = &quot;上海&quot;; this.msg = &quot;登陆成功&quot;; }, }, }; &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 指令 vue给了我们一个很大的福利——指令。 vue的指令非常强大，能帮助我们减少极其多的复杂工作。 一句话概括： vue指令是专门用于dom处理的，所有指令都只能用在dom身上 常用的vue指令：内容 v-text——渲染文本 v-html——渲染html（包括文本） 显隐 v-show——基于css控制 频繁操作中，使用show更合理 v-if——基于渲染控制 不频繁操作的时候，使用if更安全 分支 v-if if判断 v-else-if else if分支 v-else else分支 if，else if，else如果要凑成一个分支，那相关dom一定要紧挨着书写 列表 v-for v-for在实际界面渲染中显得非常重要，其基本语法和嵌套语法如下： &lt;ul&gt; &lt;li v-for=&quot;(item, index) in stus&quot; :key=&quot;index&quot;&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in workers&quot; :key=&quot;index&quot;&gt; &lt;p&gt;{{ item.name }}&lt;/p&gt; &lt;p&gt;{{ item.job }}&lt;/p&gt; &lt;p&gt; &lt;span v-for=&quot;(_item, _index) in item.skills&quot; :key=&quot;_index&quot;&gt;{{ _item }}&lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; 数据绑定 vue中使用v-model进行数据和视图的绑定，在表单应用中使用尤其多 input——收集input输入内容 radio 收集radio本身的value checkbox 收集checkbox本身的value 当v-model绑定的数据是数组时，收集value 收集true和false 当v-model绑定的数据是非数组时，收集true和false textarea——收集文本域的value select——收集option的value 事件 在vue中的事件处理监听方式和传统事件监听有一定区别，高度封装的vue将事件的监听方式也进行了一个封装 在使用事件的时候，同时需要知道一个组件的方法只能定义在【methods】属性内 事件监听语法有两种：v-on监听 &lt;button v-on:click=&quot;doAlert&quot;&gt;点击按钮，弹窗&lt;/button&gt; @监听 &lt;button @click=&quot;doAlert&quot;&gt;点击按钮，弹窗&lt;/button&gt; 事件监听的同时也可以传参： &lt;button @click=&quot;doAlert(&#39;点击了&#39;)&quot;&gt;点击按钮，弹窗&lt;/button&gt; 关于事件对象： 所有事件都默认有一个$event事件对象，可以获得当前事件上下文信息 template中vue的模板语法为我们提供了一个默认的$event事件对象，在监听事件的时候可以显式传入进去 &lt;button @click=&quot;doAlert($event,119)&quot;&gt;点击按钮，弹窗&lt;/button&gt; // instance(实例)中就可以获得$event事件对象了 ... methods: { doAlert(event, arg) { console.log(`这是参数${arg}`, event); }, }, 当事件方法没有任何参数参与的时候，定义的语句中就可以直接获取到事件对象，否则，必须显式传递$event //模板中使用test不传递任何参数 test(event) { console.log(arg, event); }, &lt;template&gt; &lt;!-- 此处有别的参数参与，所以必须显式传递$event --&gt; &lt;button @click=&quot;test(119, $event)&quot;&gt;测试事件对象&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { ... methods:{ test(arg,event) { console.log(arg, event); } } } &lt;/script&gt; 动态绑定属性v-bind &lt;img v-bind:src=&#39;imgUrl&#39; v-bind:title=&#39;imgMsg&#39; /&gt; :属性=“” &lt;img :src=&#39;imgUrl&#39; :title=&#39;imgMsg&#39; /&gt; v-bind详解 v-bind主要作用是：绑定属性 在vue中，自定义的组件可以通过属性与外界进行通信，那么我们如何为一个组件（或者原生html节点）添加属性呢？ 一句比较绝对又冒失的话： template里面的东西，基本都可以使用v-bind来添加属性 添加常规属性 &lt;!-- 基本语法： v-bind:属性名=“属性值（或变量）” --&gt; &lt;p v-bind:selfStr=&quot;str&quot;&gt;hello world&lt;/p&gt; 添加样式类名属性 &lt;!-- 基本语法： v-bind:class=&quot;{类名：flag，类名：flag}&quot; 语法解析： 通过flag来绝对多个class类名的灵活组合 --&gt; &lt;p v-bind:class=&quot;{red:flag,blue:!flag}&quot;&gt;hello world&lt;/p&gt; //&lt;span :class=&quot;classObj&quot; @mouseover=&quot;getMoney&quot; @mouseout=&quot;gunMoney&quot;&gt;&lt;/span&gt; //在data中暴露：classObj: { bg1: false, bg2: false, bg3: false }, //使用方法 getMoney() { this.classObj.bg1 = true;this.classObj.bg2 = true;this.classObj.bg3 = true;}, //gunMoney() { this.classObj.bg1 = false;this.classObj.bg2 = false;this.classObj.bg3 = false;}, 添加style行内样式 &lt;!-- 基本语法： v-bind:style=&quot;{ dom样式属性名：样式值，。。。 }&quot; 语法解析： dom样式属性名需要使用小驼峰方式，且属性值为字符串的时候需要添加引号 --&gt; &lt;p v-bind:style=&quot;{ color: &#39;red&#39;, fontWeight: &#39;bold&#39; }&quot;&gt;元宵节快乐&lt;/p&gt; v-bind还有一个最佳简写方案:【:属性名】 双向绑定 v-model //案例 &lt;template&gt; &lt;div&gt; &lt;p&gt;账号：&lt;input type=&quot;text&quot; v-model=&quot;uname&quot; /&gt;{{ uname }}&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;text&quot; v-model=&quot;pwd&quot; /&gt;{{ pwd }}&lt;/p&gt; &lt;button @click=&quot;changeReg&quot;&gt;注册&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from &quot;axios&quot;; axios.defaults.baseURL = &quot;http://139.9.177.51:8099&quot;; export default { data() { return { uname: &quot;&quot;, pwd: &quot;&quot;, }; }, methods: { changeReg() { axios .post(&quot;/users/add&quot;, { account: this.uname, password: this.pwd }) .then((res) =&gt; console.log(res.data)); }, }, }; &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; vue-router的基本使用配置routervue-router基本语法使用 vue-router是vue路由的首选插件（也是官方插件） 基本使用方法： 前提需要先下载路由 yarn add vue-router -S 根目录下创建router.js文件 引入——引入Vue和VueRouter import Vue from &#39;vue&#39; import VueRouter from &#39;vue-router&#39; 全局注册到vue中 Vue.use(VueRouter) //很多基于vue的插件和组件库都是使用vue.use来注册的 结构——创建路由数据结构 //分配具体路由 一个组件对应一个路由 路由和组件一一对应 import FindMusic from &#39;./wyy/modules/FindMusic&#39; const routes = [ { path:&#39;&#39;, component:()=&gt;import(&#39;../../MyDemo&#39;)//路由懒加载 } { path:&#39;/...&#39;, name:（通常与path路径名一致） component:A//需要的组件 } ] 实例——通过VueRouter生成实例化路由并且将路由暴露出去 //暴露 export default new VueRouter({ routes//routes：routes }) 挂载——将路由实例导出，在main.js中引入并挂载 import router from &#39;./router&#39; new Vue({ router,//router：router render: h =&gt; h(App), }).$mount(&#39;#app&#39;) 以上为路由基本使用语法 404页面配置404页面 在router.js 最下面 { path:&quot;*&quot;, name:&quot;xxx&quot;, component:&quot;&quot; } 但是！若想你的路由正常使用，你还需要一个路由出口组件：&lt;router-view&gt;，所有路有规则匹配到的组件都会在&lt;router-view&gt;，（这也是实现路由嵌套的核心组件） router-view详解 router-view是vue-router提供的一个路由入口组件，其主要作用为：根据路由规则来切换渲染对应的组件。 虽然概念简单，但实际项目应用中router-view往往和App.vue牵扯不清。 首先你需要知道一个概念：App.vue是整个vue项目中唯一保持生命活性的组件，这就是为什么App.vue被称为入口组件的原因。 那么结合App.vue我们可以得到一个结论，router-view在进行一级页面切换的时候最好就是直接让router-view代替App.vue内部的所有内容。 router-view和vue-router又有什么关系呢？ vue-router最主要的作用是给vue配置路由逻辑，让vue项目内部可以跳转路由和使用路由相关api。 router-view最主要的功能是渲染视图，当vue-router监听到浏览器规则时，将对应组件交给router-view来呈现渲染。 vue路由跳转 vue路由跳转有三种方式： 组件跳转 使用&lt;router-link /&gt;组件来实现跳转 &lt;router-link to=&quot;/hello-world&quot;&gt;跳转到hello-world（组件跳转）&lt;/router-link&gt; 函数跳转 当你在vue项目中成功配置了一个vue-router路由之后，你的项目全局范围内就会挂载一个$router大对象 $router是项目全局路由大对象，可以得到所有跟路由【处理】相关的属性和方法 在任何组件内，通过this.$router即可访问到 通过this.$router.push(path)就可以进行跳转了 jumpTo() { this.$router.push(&quot;/hello-world&quot;); } a标签跳转 使用a标签结合锚点路径来进行跳转 &lt;a href=&quot;#/hello-world&quot;&gt;跳转到hello-world&lt;/a&gt; vue路由传参 路由可以跳转，也可以传参，常用传参手段，往往是借助路由函数跳转方式进行传参。 在了解传参之前，我们还需要知道一个东西：【当前路由对象—$route】（请注意和$router全局路由对象区分开） 当前路由对象$route带有当前路由全部相关信息，通过console打印可以知道，当前路由对象$route身上带有一个params和query两个属性，这两个属性其实就可以帮助我们得到前一个路由传递来的参数了 路由传参基本语法：params传参（post）使用params传参，路由必须具备name，且只能基于name跳转 this.$router.push({name:&#39;hello-world&#39;,params:{id:1}}) //接收数据 this.$route.params params传递的参数不持久，参数不在地址栏体现，刷新页面后，就消失了 query传参（get）query既能基于path跳转，也能基于name跳转 this.$router.push({path:&#39;/hello-world&#39;,query:{id:1}}) //接收数据 this.$route.query 使用query传参，参数在地址栏上体现，且持久 实际项目中，我们在大型参数（大对象，大数组）传递时，更多使用的是本地存储 vue路由嵌套 从写法上分析，路由嵌套，最重要的地方就是路由数据结构中的【children】属性 { path: &#39;/hello-world&#39;, name: &#39;hello-world&#39;, component: () =&gt; import(&#39;@/components/HelloWorld&#39;), children: [ //当前路由下书写children子路由数据结构 { path: &#39;hello-1&#39;, component: () =&gt; import(&#39;@/components/Hello1&#39;) } ] } 从逻辑上分析，既然有二级路由，那就说明【当前路由对应的组件内还会继续进行路由规则匹配和路由组件渲染】，基于上面的描述，代表，那个组件内有子路由，那么那个组件内一定要有一个&lt;router-view&gt;&lt;/router-view&gt; Vue生命周期、计算属性、组件通信、插槽计算属性 计算属性顾名思义就是对属性的值进行计算，从而得到一个新的值。 计算属性设计的目的就是基于原本的数据来通过计算衍生出新的数据，而又不影响原本的数据 基本语法： ... computed:{ 新数据名(){ ...进行计算 return 新数据 } } 使用：{{新数据名}} 使用的时候，直接使用【新数据名】即可 计算属性的特点： 必须定义在computed内 必须以函数形态呈现 必须有返回值 计算属性最大的作用： 通过原本的数据衍生新的数据 在数据衍生过程中，可以通过观察数据变化从而进行别的行为操作 计算属性的优势： 计算属性有缓存性质，如果源数据不变，则不论使用多少次衍生数据，都只会调用一次方法 一旦源数据发生改变，则计算属性从新计算 过滤器filter（新版本已经移除） 过滤器作用和computed差不多，两者之间的区别： computed： 缓存机制 源数据生成新数据 源数据发生改变新数据也改变 filter 没有缓存机制，过滤几次调用几次 源数据生成新数据 源数据发生改变新数据也改变 &lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in stus&quot; :key=&quot;index&quot;&gt;{{ item | newStu }}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;script&gt; data() { return { stus: [&quot;杨洋&quot;, &quot;赵任杰&quot;, &quot;董家豪&quot;, &quot;霍佳俊&quot;, &quot;刘佳&quot;, &quot;陶天骄&quot;], }; }, filters: { newStu(stu) { return &quot;0928-&quot; + stu; }, }, &lt;/script&gt; 侦听器watch 在某些项目中，我们需要在数据发生改变后立即执行某些行为（而不是得到新数据），那么针对这样的情况，我们使用watch侦听器比较合适。 实际项目中，我们有时候会对诸如异步数据进行监听，此时我们需要watch来协助 基本语法： ... watch:{ 变量名&lt;data中定义的变量&gt;(newValue){ ... } } vue生命周期生命周期表示组件从创建到销毁的完整过程! 四大阶段： 诸如vue和react一类的框架，大部分都有生命周期钩子方法这么一个说法，为什么需要生命周期呢？因为我们需要建立一个组件从开始到销毁的整个节点把控系统。比如，组件刚开始渲染的时候，数据是异步的，怎么办？那就在初始化生命周期（比如create）的时候，发送ajax请求。 create阶段—–数据阶段 beforeCreate()—–数据创建之前 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined,还未初始化。 created()—–数据创建完毕 在created阶段，vue实例的数据data有了，el还没有。 注意：创建阶段：主要是处理数据（主要：对数据进行挟持，把data对象上的数据挂到了this实例上）！！ mount阶段—–渲染阶段 beforeMount()—–数据渲染之前 在beforeMount阶段，vue实例的$el和data都初始化了,单还没有挂载之前都是虚拟的demo阶段,data.message还未替换。 mounted()—–数据渲染完毕 在mounted阶段,vue实例挂载完后,data.message成功渲染。 注意：挂载阶段：主要是合成数据和视图模板，先在内存完成虚拟dom解析，最后一次dom操作直接更新到页面。 update阶段—–更新阶段 beforeUpdate()—–数据更新之前 updated()—–数据更新完毕 当data变化后,针对视图发生更新前后触发beforeUpdata和updata方法。 注意：更新阶段：主要是完成对视图的动态修改。 destroy阶段—–销毁阶段 beforeDestroy—–数据销毁之前 destroyed—–数据销毁完毕 在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经结束了事件监听以及和dom的绑定，但是dom结构依然存在。 注意：销毁阶段：主要是完成对组件的回收。 以上都可以叫做钩子函数 发请求的最佳时间发请求最佳时间：大部分场景都会操作dom，就放到created生命周期钩子函数里面 created(){ this.$nextTick(() =&gt; { /* code */ }) } 组件通信特征 所有UI框架的组件都具备通信特征，具体通信类型有三种： 父传子 属性通信 子传父 $emit,$on 兄弟传兄弟（无视层级通信） 第三方BUS集成$emit,$on 父传子（属性通信） 父传子直接基于属性通信即可，很基础 父传子案例主页面 &lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt; --&gt; &lt;Item v-for=&quot;(item, index) in goodsList&quot; :key=&quot;index&quot; :price=&quot;item.price&quot; :proname=&quot;item.proname&quot; :num=&quot;item.num&quot; :shop=&quot;item.shop&quot; :img=&quot;item.img&quot; /&gt; &lt;!-- &lt;/div&gt; --&gt; &lt;!-- &lt;/div&gt; --&gt; &lt;/div&gt; &lt;/template&gt; import Item from &quot;./Item&quot;; export default { components: { Item, }, 子页面 &lt;template&gt; &lt;div class=&quot;item&quot;&gt; &lt;img :src=&quot;img&quot; alt=&quot;&quot; /&gt; &lt;p&gt;￥{{ (price * 1).toFixed(2) }}&lt;/p&gt; &lt;p&gt;{{ proname }}&lt;/p&gt; &lt;p&gt;{{ num }}&lt;/p&gt; &lt;p&gt;{{ shop }}&lt;/p&gt; &lt;p&gt;&lt;button&gt;加入购物车&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&quot;price&quot;, &quot;proname&quot;, &quot;num&quot;, &quot;shop&quot;, &quot;img&quot;], }; &lt;/script&gt; 子传父（$emit,$on） 子传父是基于Vue自定义事件系统实现的，我们需要先认识vue的自定义事件系统 Vue构造函数原型方法中有一个$on和$emit，它俩的作用： $on 监听事件 接受数据 this.$on(&#39;事件名&#39;,data=&gt;{ ... }) $emit 触发事件 传递数据 this.$emit(&#39;事件名&#39;,&#39;要传递的数据&#39;) 关于$on和$emit的配合，我们需要知道的是： Vue是整个应用最大的上下文 $on监听的事件和执行函数，都挂载到了Vue身上 $emit触发事件，就是去Vue身上找到对应事件，从而调用事件方法 而每一个组件其实都继承自Vue，所以，基于$on和$emit我们可以随意进行数据传递（最好使用BUS，详见后文） 回到子传父，其基本思路就是： 子组件内部通过this.$emit触发事件 父组件通过@或者v-on在子组件标签身上监听事件 兄弟传兄弟（无视层级通信）（第三方BUS集成$emit,$on） 其实本质上就是上面$on和$emit的一个函数式写法。 在无视层级的书写过程中，我们往往需要一个第三方独立空间来管理监听的事件，此时非常推荐使用一个全新独立的Vue实例。 实现思路： 创建一个BUS文件:内部暴露一个Vue的实例 在需要发送数据的组件内，合适的位置，使用BUS.$emit来触发自定义事件 在需要接受数据的组件内，mounted生命周期，使用BUS.$on来监听事件 组件实例通信 在vue中有一个叫ref的api，他让我可以获取一个组件的实例，一旦获取到组件实例后，当前组件相关数据和方法我们都可以无障碍使用了 首先，ref的使用方式： &lt;组件 ref=&quot;标记名&quot;&gt;&lt;/组件&gt; 获取标记的ref： this.$refs[标记名] 注意：通过ref，可以获取子组件身上大部分信息，是通信环节中比较重要的一环。但是，仅限于父组件获取子组件信息的场景 组件详解 vue组件的一些基本特性： 视图模板——template 自身逻辑——script 接受属性——props 通信特征 自定义事件 v-model语法糖应用 组件视图模板 视图模板主要指的是&lt;template&gt;&lt;/template&gt; 组件自身逻辑 组件自身逻辑主要指的是&lt;script&gt;&lt;/script&gt;,而一个组件逻辑内部常用的一些设定都有： data——定义组件自身内部数据 必须，data必须是函数 必须，data必须返回一个对象，对象内就是定义的组件自身的数据 props——定义组件的属性 对象形式，数组形式 对象形式的常用书写语法： // 属性名：属性类型 props:{ num:Number, words:String } // 完整声明+自定义规则 props:{ num:{ type:Number, // 类型 default: 10 //默认值 } } // 引用类型声明和基本类型有区别 props:{ obj:{ type:Object, default:()=&gt;({name:&#39;张三&#39;,age:30}) }, arr:{ type:Array, default:()=&gt;([1,2,3,4,5]) } } 数组形式的常用书写方法 props:[&#39;num&#39;,&#39;arr&#39;,&#39;obj&#39;] methods——定义组件自身的方法watch——监听组件内部数据的变化computed——计算属性，根据当前数据衍生出新的数据生命周期钩子——在每一个生命周期阶段，自动执行filter——过滤器（新版本已经废除）components——注册子组件插槽 定义：插槽，能帮助我们让组件具有容器特性。一个设置了插槽的组件就可以包含别的内容（组件）了 插槽分为三种： 匿名插槽 具名插槽 作用域插槽（重难点） 匿名插槽 在组件内直接定义&lt;slot&gt;&lt;/slot&gt;，就可以接受外界被包含的内容了 组件：SlotCmpt&lt;template&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;这是一个带有插槽的组件&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 使用方式：&lt;SlotCmpt&gt; &lt;h1&gt;这是包含的内容&lt;/h1&gt; &lt;/SlotCmpt&gt; 具名插槽 顾名思义，就是为每一个插槽取一个名字，然后放置内容的时候都需要声明是那个插槽的内容 组件：NamedSlot&lt;template&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;这是一个具名插槽&lt;/p&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 使用方式：&lt;NamedSlot&gt; &lt;template v-slot:header&gt; &lt;h1&gt;这是头部&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;h1&gt;这是底部&lt;/h1&gt; &lt;/template&gt; &lt;/NamedSlot&gt; 作用域插槽 作用域插槽是插槽中和具名插槽使用频率不相上下的一个板块 作用域插槽在组件通信中使用频率非常高！如果你希望做一个非常智能的组件，作用域插槽一定可以帮到你！ 组件：ScopeSlot&lt;template&gt; &lt;div&gt; &lt;p&gt;这是一个作用域插槽&lt;/p&gt; &lt;!-- 外界接收到的作用域对象长这样： {name1,name2,name3} --&gt; &lt;slot :person1=&quot;name1&quot; :person2=&quot;name2&quot; :person3=&quot;name3&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 使用方式：&lt;div&gt; &lt;p&gt;下面颁发今年源码时代，最受欢迎原创代码奖：&lt;/p&gt; &lt;ScopeSlot&gt; &lt;!-- 1.此处的persons是自己定义的名字 2.persons代表了子组件内整个作用域插槽 --&gt; &lt;template v-slot=&quot;persons&quot;&gt; {{ persons }} &lt;/template&gt; &lt;/ScopeSlot&gt; &lt;!-- 还可以通过解构的方式来获取子组件的数据 --&gt; &lt;ScopeSlot&gt; &lt;template v-slot=&quot;{ person1 }&quot;&gt; {{ person1 }} &lt;/template&gt; &lt;/ScopeSlot&gt; &lt;/div&gt; Vue路由守卫导航守卫的定义 正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。 记住参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。 守卫分类全局前置守卫 用法：你可以使用 router.beforeEach 注册一个全局前置守卫 const router = new VueRouter({ ... }) router.beforeEach((to, from, next) =&gt; { // ... }) 解析：当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。 每个守卫方法接收三个参数： to: Route 即将要进入的目标 路由对象 from: Route 当前导航正要离开的路由 next: Function 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(&#39;/&#39;) 或者 next({ path: &#39;/&#39; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: &#39;home&#39; 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。这里有一个在用户未能验证身份时重定向到 /login 的示例： // BAD router.beforeEach((to, from, next) =&gt; { if (to.name !== &#39;Login&#39; &amp;&amp; !isAuthenticated) next({ name: &#39;Login&#39; }) // 如果用户未能验证身份，则 `next` 会被调用两次 next() }) // GOOD router.beforeEach((to, from, next) =&gt; { if (to.name !== &#39;Login&#39; &amp;&amp; !isAuthenticated) next({ name: &#39;Login&#39; }) else next() }) 全局解析守卫 在 2.5.0+ 你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。(2.5.0新增) 全局后置钩子 你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身 router.afterEach((to, from) =&gt; { // ... }) 路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫，这些守卫与全局前置守卫的方法参数是一样的。 const router = new VueRouter({ routes: [ { path: &#39;/foo&#39;, component: Foo, beforeEnter: (to, from, next) =&gt; { // ... } } ] }) 组件内的守卫 最后，你可以在路由组件内直接定义以下路由导航守卫： beforeRouteEnterbeforeRouteUpdate (2.2 新增)beforeRouteLeaveconst Foo = { template: `...`, beforeRouteEnter(to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 }, beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` }, beforeRouteLeave(to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` } } beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 beforeRouteEnter (to, from, next) { next(vm =&gt; { // 通过 `vm` 访问组件实例 }) } 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。 beforeRouteUpdate (to, from, next) { // just use `this` this.name = to.params.name next() } 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 beforeRouteLeave (to, from, next) { const answer = window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;) if (answer) { next() } else { next(false) } } 完整的导航解析流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Vue2.0介绍","slug":"Vue2-0介绍","permalink":"/tags/Vue2-0介绍/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Git","slug":"git的基本使用","date":"2021-03-20T13:48:09.000Z","updated":"2021-07-26T17:06:24.580Z","comments":true,"path":"2021/03/20/git的基本使用/","link":"","permalink":"/2021/03/20/git的基本使用/","excerpt":"","text":"GIT和SVN版本控制工具GIT的作用 提高多人协作开发时的效率 给不同的版本打上版本号 GIT工作流 第一次使用GIT时： 克隆项目：将远程仓库里面的项目克隆到本地仓库，本地仓库会自动检出到本地工作区（克隆项目只需要做一次即可） 命令： git clone 远程仓库的地址 上传项目： 将本地工作区的新增和修改的文件添加到暂存区 git add . 将暂存区的文件提交到本地仓库 git commit -m ‘提示信息‘ (提示信息请务必写完整) .首次commit会提示设置邮箱和用户名： a) git config –global user.email “you@example.com” b) git config –global user.name “Your Name” 将本地仓库里面的文件推送到远程仓库 git push 注意： 如果是第一次推送 使用命令 git push -u origin master 补充： 查看文件的状态 git status 第二次及以后使用GIT时：上传项目： 拉取项目： git pull (重点：先拉取 在写代码） 将本地工作区的新增和修改的文件添加到暂存区 git add . 将暂存区的文件提交到本地仓库 git commit -m ‘提示信息‘ (提示信息请务必写完整) 将本地仓库里面的文件推送到远程仓库 git push 注意： 如果是第一次推送 使用命令 git push -u origin master 补充： 查看文件的状态 git status 常用分支操作 查看当前仓库的所有分支(本地分支和远程分支)情况：git branch -a 创建并切换到一个新的分支：git checkout -b 分支名 将本地新分支的代码上传到远程仓库同一个新分支下面： git push -u origin 新分支的名字 切换到已有分支（注意需要先把变更提交）git checkout 分支名 将其他分支的代码合并到当前分支（需要先切换到当前分支）：git merge 其他分支名 如何将未建立仓库的本地项目上传到远程仓库 新建一个空的远程仓库 切换到本地项目根目录， 使用git init命令 初始化项目 git add . git commit -m ‘提示信息’ git remote add 远程地址 git push -u origin master 常用的命令行代码 切换目录： cd 切换到上一级： cd ../ 新建目录：mkdir 目录名 新建文件： type nul&gt;文件名 删除目录：rm -rf 目录名 (删除目录时一定要返回到上一级） 删除文件：rm 文件名 查看当前目录下的所有文件： ls 清屏： clear commit 备注规范feat：新功能（feature） //常用 fix：修补bug //常用 docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 git提交取消提交的文件新建文件 .gitignorenode_modules dist yarn.lock .vscode .DS_Store # local env files .env.local .env.*.local # Log files npm-debug.log* yarn-debug.log* yarn-error.log* # Editor directories and files .idea .vscode *.suo *.ntvs* *.njsproj *.sln *.sw* git的详细使用仓库 定义：仓库从字面上来看，就是用于存储东西的。git本意是一个代码版本控制器，它可以在你的本地（或远程）为你生成一个用于管理代码版本的目录，我们将这个可以管理代码的目录称之为仓库。 git和github和gitLab和gitee和coding有什么关系呢？ 其实真正意义上来看，有关系的是后面几个，不是git和他们。 github、gitLab、gitee、coding这几个东西都是用于发布和管理远程在线仓库的平台，他们都是基于git的在线代码管理中台。 git和svn的区别git 分布式版本管理系统 每一个成员都能完整拷贝所有代码，且如果作为中枢服务的成员电脑宕机了，那么立即就可以有另一个成员作为中枢，用于所有人的代码提交和拉取 svn 集中式版本管理系统 必须有一台中枢电脑（服务），所有成员只能提交到中枢服务上。一旦中枢服务宕机，那么只能重新搭建新的服务，成员们重新拉取或重新映射服务 Git本地不联网就可以提交，联网后，再同步多次提交的记录，而SVN的提交必须联网 切换分支的成本：Git可以快速切分支（快照原理），秒切，而SVN的分支其实就是文件目录，切分支要进行文件的重新下载 git与svn哪一个比较好 git对于代码管理非常友好和灵活 svn对于文件管理非常方便 分支本地仓库初始化 在需要初始化的目录内，右键打开bash，再运行命令： git init 此时会受到一条提示信息： Initialized empty Git repository in C:/Users/Administrator/Desktop/rpo/.git/ 这是告知你，当前本地仓库初始化完成，你拥有了一个空仓库 默认分支 在空仓库创建完成后，你运行以下命令： git branch // 查看本地分支 git branch -a // 查看本地全部分支 你会发现，什么都没有。可是请你仔细观察你当前盘符地址，你会发现，你的地址最后有一个(master)标识，说明你现在所处的是master分支。可为什么你无法运行命令查看到master呢？ 新版本的git，在文件操作过程中会忽略空目录，在分支操作过程中会忽略空分支 此时，请在当前master分支下，回到目录中创建一个txt文件，再运行添加和提交 git add . git commit -m &#39;创建文本文件——xxx&#39; 一切搞定后，再运行查看分支命令，会发现：master出现了 认识分支 分支，其实就是当前仓库内容的一个拷贝，每一个分支是一份独立的仓库内容。 查看分支，命令：git branch // 查看本地分支 git branch -a // 查看本地所有分支 git branch -r // 查看远程分支 创建分支，命令：git checkout -b 分支名 //创建并进入新分支 这个过程中，我基于当前所处分支，将所有内容拷贝了一份，成立了一个新的分支，这是基于最新代码，创建开发分支最常用的方式 切换分支，命令：git checkout 分支名 修改分支名，命令：git branch -m 旧的分支名 新的分支名 删除分支，命令：// 先切换到别的分支，才可以删除当前分支。 git branch -D 分支名 分支的区别 每一个分支都是独立的，不会相互影响。你在某个分支内进行的所有操作，都仅限于当前分支，一旦切换分支后，就会只呈现你切换到的那个分支内容了。 主分支 每一个仓库都会有一个主分支，一般情况下以master作为主分支。主分支的作用是： 主分支具备整个仓库最完整，最新的内容 所有开发分支都需要将代码合并到主分支内（一般都在远程仓库进行） 获取最新代码都需要从主分支身上获取（一般采取合并分支方式实现） 切记！！！开发的时候，本地一定不要去修改master，它只做获取最新代码用 工作(重要) 在工作中那我们应该如何操作本地的仓库和分支呢？ 首先将仓库克隆下来 基于master创建自己的开发分支 这么做的目的是为了基于master拿到最新代码 开发完成后将自己的分支推送到远程，推送之前务必更新master，合并master上最新代码到自己的分支 下班前务必更新一次master，拿到所有人最新代码 第二天上班后，要做的第一件事——在master拉取最新代码 暂存区 在本地仓库内，当你做完一部分修改的时候，你需要执行以下两个步骤才能将修改提交到仓库内： git add git commit 此处我们重点描述以下git add发生了什么，以及他的内容到了哪儿？ 在本地仓库，有一个缓存空间，我们将其称为暂存区，暂存区的内容是时刻紧跟分支走的。如果你在错误的分支进行了add，想要把add的内容带到正确的分支，你可以直接checkout切换分支即可 工作区 工作区对应的是commit操作，当执行commit后，你的修改会被添加到工作区。一个分支就是一个工作区。如果你需要将某个工作区的commit切换到另一个工作区，那么你需要执行以下步骤： 总结：先合并，再回退 你可以像这样： 先将当前错误提交的代码，合并到你想要的的那个分支去 回到错误提交的分支，回退版本到上一次commit即可 合并 合并代码有两种方式： git merge 一般合并后不会出现vi编辑器来编辑相关信息 git rebase -i 需要合并的分支 一般合并后会出现vi编辑器来编辑信息 rebase的时候，一旦成功，多数情况下会出现一个vi命令行编辑器的界面。我们对这个界面需要了解一些简单操作： 按下键盘i（同时仔细观察左下角会出现一个insert），代表当前可以输入内容了 按下键盘ESC，（同时观察左下角什么标识都不会出现），代表当前退出了编辑模式 按下ESC紧接着按下:wq（同时观察左下角，你输入的:wq会出现）,代表保存并退出 git merge和git rebase -i的区别，主要体现在时间线！ 总结一句话：站在自己的分支合并master最新代码应该使用rebase -i，主动用master去合并自己分支的代码应该使用merge。 冲突 在没有连续时间线的前提下，对同一个文件，同一个地方进行了修改则会造成冲突！ 什么叫做连续时间线？ 我先修改，你合并了，然后再修改，这叫连续时间线。这不会导致冲突 识别冲突 如果你在合并的时候，你的分支出现以下症状： 分支名变成了(分支名 | merging 或 rebae) git同时提示你很多信息，在提示的信息中，你找到了conflict关键词 解决冲突 当冲突发生后，你应该做的事。 rebase的情况下 打开vscode，修复冲突位置 运行 git add . 运行git rebase –continue 让合并继续下去 merge的情况下 打开vscode，修复冲突位置 运行git add . 运行git commit 让merge继续下去 另外小tips：有时候你可能不希望去处理冲突，那么可以选择取消合并 rebase取消合并 git rebase –abort merge取消合并 git merge –abort 远程&amp;本地 远程：大家一起玩儿 本地：自己跟自己玩儿 远程仓库往往是多个成员一起维护的，A、B、C三个成员一起维护一个项目，A和B提交了代码到远程，C必须等待A和B的代码合并到远程master内以后才可以拉取最新代码。 所以一般我们远程仓库的工作流程： 将自己的分支提交到远程仓库 git push origin 分支名:分支名 这句代码会将本地分支提交到远程，如果远程没有则创建且关联。从此以后，这个分支的远程推送只需要git push即可 浏览器打开远程仓库控制台，基于自己的分支发送合并请求 管理员审批合并请求，务必查看分支是否冲突！以及仔细甄别成员修改的文件列表！ 提交错误时 当你修改后commit提交到工作区了，此时后悔的话，可以使用版本回退。如何实现呢？ 使用git log来找到你希望回退到的版本号 复制你想回退到的版本号（一小段即可） 运行命令git reset --hard 复制的版本号","categories":[{"name":"管理","slug":"管理","permalink":"/categories/管理/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[{"name":"管理","slug":"管理","permalink":"/categories/管理/"}]},{"title":"Node Js、Webpack","slug":"NodeJs、Webpack的基本使用","date":"2021-03-15T08:16:13.000Z","updated":"2021-07-26T16:43:38.455Z","comments":true,"path":"2021/03/15/NodeJs、Webpack的基本使用/","link":"","permalink":"/2021/03/15/NodeJs、Webpack的基本使用/","excerpt":"","text":"Node Js入门及配置Node安装 下载msi文件 傻瓜式安装 nodejs 安装路径：C:\\Program Files\\nodejs\\ 打开cmd命令行工具 node -v npm -v dos命令 dir 查询目录及目录下所有文件 cd 路径 跳转到某个路径 盘符： 切换路径到某个盘符 cls 清屏 ctrl+c 中断程序 快捷进入某个目录 直接在目录的路径上 输入 cmd 环境变量配置 此电脑–右键–属性 高级系统设置 环境变量 path 添加 C:\\Program Files\\nodejs\\ 到path 的最后 Node运行js代码 直接运行js文件 node js文件路径 直接运行js代码 node let a=100;let b=1000;conosle.log(a+b); Node模块 一个js文件就是 一个模块 模块与模块之间 有 依赖关系 包：多个模块组合起来的 主模块：整个项目的入口 模块的导入与导出 注意：js模块中能够导入任何的文件格式 css .mp4 .jpg js模块导入其他文件格式的语法 require(&#39;文件路径&#39;) // 相对路径 绝对路径 完整的url地址 js模块导入js模块的语法 js模块导出 //a.js let str = &#39;xxzczxczxcxzc&#39;; let arr = [12112, 48, 45, 54, 45]; let name = &#39;张麻子&#39;; //导出语句-暴露 module.exports = { str, arr, name } js模块导入 //b.js---主模块 //导入的文件 //接收暴露的数据 let a = require(&#39;./a.js&#39;); console.log(a); console.log(a.str); cmd Node环境运行 node b.js css文件相互引入/*base.css*/ p { font-size: 40px; font-weight: 600; } /*index.css*/ /*css文件引入其他的css文件 方法*/ @import url(&#39;./base.css&#39;); p { color: red; } 三方包的使用npm的用法 作用：三方包管理工具 npm官网 淘宝镜像 npm常用命令npm init # 创建项目/初始化项目 npm install 包名 # 下载三方包 npm install 包名@版本号 # 下载具体的某个版本的包 npm install 包名 -D #下载开发环境使用的包 npm install -g 包名 #全局安装某个包 npm uninstall 包名 # 卸载三方包 npm install # 下载所有的包 npm init创建项目 作用：创建/初始化项目–package.json 文件 { &quot;name&quot;: &quot;demo&quot;, //项目名 &quot;version&quot;: &quot;1.0.1&quot;, //版本号 &quot;description&quot;: &quot;&quot;, //描述信息 &quot;main&quot;: &quot;index.js&quot;, //入口文件--主模块 &quot;scripts&quot;: { //命名工具 &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, //作者 &quot;license&quot;: &quot;ISC&quot; //开源协议 } 案列示范（导入jQuery包）//在项目根目录下 npm install jquery //在入口文件-主模块 index.js let jquery = require(&#39;jquery&#39;); console.log(jquery); yarn安装 作用：三方包管理工具 npm install -g yarn C:\\Users\\Administrator\\AppData\\Roaming\\npm 删除所有的 .ps1文件 yarn init -y #快速创建/初始化项目 yarn add 包名 # 安装三方包 yarn add 包名@版本号 #安装某个版本号的包 yarn add 包名 -D #安装本地开发环境的三方包 yarn add global 包名 # 全局安装三方包 yarn remove 包名 #删除包 yarn #一次性安装所有的包 [注意]全局安装使用npm ​ 项目依赖安装使用yarn 设置镜像源npm设置淘宝镜像npm config set registry https://registry.npm.taobao.org npm config get registry yarn设置淘宝镜像yarn config set registry https://registry.npm.taobao.org yarn config get registry Webpack的基本使用 webpack作用 将node环境下 js代码及各种资源文件转换为 浏览器可运行的静态资源 将大文件 进行压缩 将代码进行混淆 webpack处理的文件 js文件 css 文件 less sass stylus scss 图片 webpack5大核心概念【重点】 entry 入口文件 output 出口文件 loader 解释器 plugins 插件 mode 环境 webpack安装及初始化项目 全局安装 webpack webpack-cli npm install webpack@5.11.0 webpack-cli -g 删除npm 文件中所有的 .ps1 文件【避坑】 目录： C:\\Users\\Administrator\\AppData\\Roaming\\npm 项目初始化 yarn init -y yarn add webpack@5.11.0 webpack-cli -D 项目目录结构webpack-demo ├── src │ ├── css │ ├── fonts │ ├── img │ ├── js │ └── index.html ├── package.json ├── webpack.config.js └── yarn.lock 配置webpack.config.js/**webpack 打包配置文件 * author:cometang 2021-06-12 */ module.exports = { //五大概念导出 //入口 entry: &#39;&#39;, //出口 output: { filename: &#39;bundle.js&#39; }, // loader 解释器 module: { rules: [ //使用什么loader 对什么格式的文件 进行解释 { test: /\\.css$/, use: &#39;&#39; } ] }, //plugins 插件 plugins: [ ], //mode 环境 //development 本地开发环境 // production 线上生成环境 mode: &quot;development&quot; } 打包js文件 目的：让原来不能够在浏览器运行的js文件能够支持运行 前提工作： 创建 index.html index.js main.js(主模块) webpack-demo ├── .vscode │ └── settings.json ├── dist │ └── bundle.js ├── src │ ├── css │ ├── fonts │ ├── img │ ├── js │ │ ├── index.js │ │ └── main.js │ └── index.html ├── package.json ├── webpack.config.js └── yarn.lock 修改webpack.config.js 配置 //导入 nodejs 内直模块 获取项目根目录绝对路径 const path = require(&#39;path&#39;); //入口 entry: &#39;./src/js/main.js&#39;, //出口 output: { // 出口文件 放置的位置 必须是绝对路径 // 出口文件的 文件名 path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;bundle.js&#39; }, &lt;body&gt; &lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; 项目根目录下-cmd 命令行窗口 输入打包命令 webpack 打包css文件 css文件支持打包 css相互引入之后一样可以打包 js中导入的css文件可以打包 修改配置文件 下载 css-loader style-loader 配置loader module yarn add css-loader style-loader -D // loader 解释器 module: { rules: [ //使用什么loader 对什么格式的文件 进行解释 //css-loader 让webpack 可以打包css代码 //style-loader 将打包完成之后的css代码 添加页面的 head-style标签中 { test: /\\.css$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;] } ] }, 打包less文件less语法/*变量*/ @bgcolor:#f60; @fsize:14px; /*嵌套语法 嵌套层数不要超过三层*/ .box{ width:200px; height: 200px; background-color: aqua; .box1{ width: 150px; height: 150px; background-color: @bgcolor; .box2{ width: 100px; height: 100px; background-color: #000; } } } 修改配置文件 下载loader 及less yarn add less-loader less -D 配置loader module: { rules: [ //使用什么loader 对什么格式的文件 进行解释 //css-loader 让webpack 可以打包css代码 //style-loader 将打包完成之后的css代码 添加页面的 head-style标签中 { test: /\\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] }, { test: /\\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] } ] }, 打包css中的图片 下载loader url-loader file-loader 配置loader yarn add url-loader file-loader -D { test: /\\.(jpg|png|gif)$/, loader: &#39;url-loader&#39;, /** 详细配置*/ options: { //hash 随机32为字符 ext 获取文件后缀 name: &#39;[hash:16].[ext]&#39;, //小于20kb base64压缩 大于20kb 不进行压缩 limit: 20 * 1024 } } 打包html中的图片 思路：因为html中的图片 是img src属性，直接打包html 页面就可以附带实现图片的打包 下载loader plugin html-loader html-webpack-plugin 配置loader 配置plugin yarn add html-loader@1.3.2 html-webpack-plugin@5.0.0-beta.1 -D { test: /\\.html$/, loader: &#39;html-loader&#39; } //导入三方插件包 const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;) //plugins 插件 plugins: [ new HtmlWebpackPlugin({ //以哪个页面作为打包的页面模板--打包哪个页面 template: &#39;./src/index.html&#39; }) ], 注意:配置完成之后，删除html文件中的 bundle.js引入 打包js中的图片let picDom = document.querySelector(&#39;.pic&#39;); let img = document.createElement(&#39;img&#39;); //以模块的方式导入图片 img.src = require(&#39;../img/1.jpg&#39;); picDom.appendChild(img); 优化html中引入静态资源路径设置为相对路径 //出口 output: { // 出口文件 放置的位置 必须是绝对路径 // 出口文件的 文件名 path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;bundle.js&#39;, //设置静态资源请求的 相对路径 publicPath: &#39;./&#39; }, 图片打包 用ES规范进行打包压缩 { test: /\\.(jpg|png|gif)$/, loader: &#39;url-loader&#39;, /** 详细配置*/ options: { //hash 随机32为字符 ext 获取文件后缀 name: &#39;[hash:16].[ext]&#39;, //小于20kb base64压缩 大于20kb 不进行压缩 limit: 20 * 1024, esModule: false //图片打包设置为 Es规范进行打包 不使用commonjs规范 } }, 打包字体图标 下载loader file-loader 配置loader yarn add file-loader -D { test: /\\.(svg|ttf|eot|woff|woff2)$/, loader: &quot;file-loader&quot; } 主模块引入iconfont.css /*导入字体图标 css文件 */ require(&#39;../fonts/iconfont.css&#39;) ES6转ES5 下载loader 和plugin 配置loader 项目根目录下 创建 并配置 .babelrc 文件 yarn add babel-core babel-loader@7.1.5 babel-preset-es2015 -D { test: /\\.js$/, loader: &#39;babel-loader&#39;, // loader 编译es6为es5 exclude: /node_modules/ // 排除 } .babelrc { &quot;presets&quot;: [ &quot;es2015&quot; ] } 配置开发服务 下载插件 配置 webpack.config.js 配置package.json yarn add webpack-dev-server -D //开发服务配置 devServer: { contentBase: path.resolve(__dirname, &#39;dist&#39;), // 启动服务器目录 compress: true, // 启动gzip port: 8081, // 端口 8080 80 8081 8082 open: true, // 自动打开服务 publicPath: &#39;/&#39;, // 静态资源查找路径 openPage: &#39;index.html&#39;, // 打开的页面 }, target: &#39;web&#39;, // 目标是浏览器 &quot;scripts&quot;: { &quot;serve&quot;: &quot;webpack serve&quot;, &quot;build&quot;: &quot;webpack&quot; }, 启动本地服务npm run serve yarn serve 打包线上的服务npm run build yarn build 单页应用优化-多页应用打包单页应用优化：文件整理js文件整理 output: { // 出口文件 放置的位置 必须是绝对路径 // 出口文件的 文件名 path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;js/[name].js&#39;, //设置静态资源请求的 相对路径 publicPath: &#39;./&#39; }, css文件整理 将js中的css代码提取出来 生成独立的css文件 安装两个插件 将css文件引入到html 修改配置文件 安装插件 yarn add mini-css-extract-plugin optimize-css-assets-webpack-plugin -D 配置 //css提取并通过link方式引导页面的插件 const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;); //plugins 插件 plugins: [ new HtmlWebpackPlugin({ //以哪个页面作为打包的页面模板--打包哪个页面 template: &#39;./src/index.html&#39; }), new MiniCssExtractPlugin({ filename: &#39;css/[name].css&#39; // 输出到css文件夹里 }), new OptimizeCssAssetsWebpackPlugin() ], //取消 style-loader 的加载方式 更换为 link引入 { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;] }, { test: /\\.less$/, use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;less-loader&#39;] }, 图片文件整理 { test: /\\.(jpg|png|gif)$/, loader: &#39;url-loader&#39;, /** 详细配置*/ options: { //hash 随机32为字符 ext 获取文件后缀 name: &#39;[hash:16].[ext]&#39;, //小于20kb base64压缩 大于20kb 不进行压缩 limit: 20 * 1024, esModule: false, //图片打包设置为 Es规范进行打包 不使用commonjs规范 outputPath: &#39;img&#39; } }, 字体图标文件整理 { test: /\\.(svg|ttf|eot|woff|woff2)$/, loader: &quot;file-loader&quot;, options: { outputPath: &#39;fonts&#39; //输出的目录 } }, 修复 css中背景图的路径问题 { test: /\\.css$/, use: [{ loader: MiniCssExtractPlugin.loader, options: { publicPath: &#39;../&#39; } }, &#39;css-loader&#39;] }, { test: /\\.less$/, use: [{ loader: MiniCssExtractPlugin.loader, options: { publicPath: &#39;../&#39; } }, &#39;css-loader&#39;, &#39;less-loader&#39;] }, 自动清除dist 下载插件 配置插件 yarn add clean-webpack-plugin -D //自动清除dist const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;) //plugin 添加 new CleanWebpackPlugin()","categories":[{"name":"管理","slug":"管理","permalink":"/categories/管理/"}],"tags":[{"name":"Node、Webpack","slug":"Node、Webpack","permalink":"/tags/Node、Webpack/"}],"keywords":[{"name":"管理","slug":"管理","permalink":"/categories/管理/"}]},{"title":"H5","slug":"H5","date":"2021-02-25T02:46:33.000Z","updated":"2021-07-25T19:27:04.203Z","comments":true,"path":"2021/02/25/H5/","link":"","permalink":"/2021/02/25/H5/","excerpt":"","text":"H5新DOMApi、存储技术H5新增语义化标签 header 头部 main 内容区域 nav 导航栏 footer 底部 section 定义文档某个区域 aside 侧边栏 H5中表单中的input type值【重点】选择器类 color 颜色选择器 data 时间选择器 datetime-local 日期时间选择器 month 月份选择器 week 周选择器 time 事件选择器 &lt;input type=&quot;color&quot;&gt; 限制类 number 限制用户只能输入0-100的数字 &lt;input type=&quot;number&quot; min=&quot;0&quot; max=&quot;100&quot;&gt; H5新增的表单元素 datalist 下拉列表（可搜索）【没使用】 keygen 秘钥生成器 【弃用】 output 显示计算结果 【没用】 H5的新属性【重点】 data-* 盲人辅助提醒 data-* 元素的属性【重点】自定义属性 &lt;li data-id=&quot;4&quot;&gt;444&lt;/li&gt; 获取自定以属性 li.dataset[&#39;id&#39;] contenteditable 可编辑区域 &lt;div class=&quot;box&quot; contenteditable&gt;&lt;/div&gt; boxDom.contentEditable = true; tabindex tab键切换焦点的顺序 作用：根据设置的值 来排列切换焦点的顺序 &lt;input type=&quot;text&quot; tabindex=&quot;5&quot;&gt;&lt;input type=&quot;text&quot; tabindex=&quot;1&quot;&gt;&lt;input type=&quot;text&quot; tabindex=&quot;3&quot;&gt;&lt;input type=&quot;text&quot;tabindex=&quot;4&quot;&gt;&lt;input type=&quot;text&quot; tabindex=&quot;5&quot;&gt; 本地存储【重点】会话级存储：sessionStorage 会话级存储：浏览器打开时开始会话，数据有效，当浏览器关闭时，数据会自动清除 数据的操作：增 删 改 查 新增/修改数据setItem(&#39;key&#39;,data); 删除指定一个数据removeItem(&#39;key&#39;); 删除所有数据clear(); 获取指定某一个数据sessionStorage.getItem(&#39;username&#39;,&#39;张麻子&#39;) 永远级存储：localStorage 永远级存储：数据一旦存在，永远存在，浏览器不会自动清除，人为清除（代码，缓存） 数据的操作：增 删 改 查 新增/修改数据setItem(&#39;key&#39;,data) 删除指定一个数据removeItem(&#39;key&#39;) 删除所有数据clear() 获取指定某一个数据localStorage.getItem(&#39;username&#39;,&#39;黄四郎&#39;) JSON操作【重点】 JSON：一种特殊的数据格式 JSON.stringify() 将js的复杂数据类型转换为JSON字符串 JSON.parse() 将JSON字符串转换为js复杂数据类型 let arr = [&#39;张麻子&#39;, &#39;123456&#39;, [1, 2, 2, 22]]; //1.将复杂数据类型 转换为json字符串 let arr1 = JSON.stringify(arr); //2.存 json数据 localStorage.setItem(&#39;data&#39;, arr1) //3.取数据 let arr2 = localStorage.getItem(&#39;data&#39;); //4.将json字符串 转换 js 复杂数据类型 let arr3 = JSON.parse(arr2); console.log(arr3); et userInfo = { name: &#39;张麻子&#39;, pwd: &#39;123456&#39;, msg: &#39;我是土匪&#39; } // 1-2 localStorage.setItem(&#39;user&#39;, JSON.stringify(userInfo)); //3-4 let obj = JSON.parse(localStorage.getItem(&#39;user&#39;)); H5多媒体及案例、定理定位音视频的操作视频标签 video 视频 video 属性 src 视频文件的路径（相对路径 绝对路径 完整的url） controls 视频的控制台 显示：播放/暂停 进度条 width 宽度 height 高度 autoplay 自动播放（必须静音） muted 静音 loop 循环播放 video 方法 load（） 重新播放 pause() 停止播放 play() 继续播放 video 事件 ended 监听视频播放结束触发 音频标签 audio 音频 audio 属性 src 音频文件地址（相对路径 绝对路径 完整url ） controls 控制台 （必须写） loop 自动循环播放 audio 方法 load（） 重新播放 pause() 停止播放 play() 继续播放 audio 事件 ended 监听音频播放结束触发 地图定位原生语法navigator.geolocation.getCurrentPosition(successCallback,errorCallback) 高德地图的使用 1.百度搜索 高德地图开放平台 注册账号—认证账号【如果已经注册就直接 手机号+验证码+登录】 控制台—我的应用—创建应用—点击应用“添加”—[选择：js api ] 获取：应用的私钥 key : 237057c705c1f918e38ba9196b96d646 高德地图 应用： 开发支持 web端 —地图JS-api—-示例中心 修改key 为自己的key值 坐标拾取器 svg矢量图的认识 作用：一种特殊图片格式（随着方法不会变得模糊） img src css background-image：url(‘xxxx.svg’) css3中的选择器层次选择器 E F 包含选择符(Descendant combinator) CSS1 选择所有被E元素包含的F元素。 递归遍历所有子元素孙子元素 E&gt;F 子选择符(Child combinator) CSS2 选择所有作为E元素的子元素F。遍历第一层子元素 E+F 相邻选择符(Adjacent sibling combinator) CSS2 选择紧贴在E元素之后F元素。 E~F 兄弟选择符(General sibling combinator) CSS3 选择E元素之后所有兄弟元素F。 动态伪类选择器 E:link CSS1 设置超链接a在未被访问前的样式。 E:visited CSS1 设置超链接a在其链接地址已被访问过时的样式。 E:hover CSS1/2 设置元素在其鼠标悬停时的样式。 E:active CSS1/2 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 E:focus CSS1/2 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。 结构伪类选择器 选择符 版本 描述 E:first-child CSS2 匹配父元素的第一个子元素E。E元素必须是某个元素的子元素，最高是body.first-child必须是兄弟中的第一个 E:last-child CSS3 匹配父元素的最后一个子元素E。 E:only-child CSS3 匹配只有一个子节点的子元素。 E:nth-child(n) CSS3 匹配父元素的第n个子元素E。 2n 偶数 2n-1 奇数 E:nth-last-child(n) CSS3 匹配父元素的倒数第n个子元素E。 E:first-of-type CSS3 匹配同类型中的第一个同级兄弟元素E。 E:last-of-type CSS3 匹配同类型中的最后一个同级兄弟元素E。 E:only-of-type CSS3 匹配同类型中的唯一的一个同级兄弟元素E。 E:nth-of-type(n) CSS3 匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n) CSS3 匹配同类型中的倒数第n个同级兄弟元素E。 E:empty CSS3 匹配没有任何子元素（包括text节点）的元素E。如果选中的元素中有代码有换行在里面（换行带了文本节点），会选不中。 否定伪类选择器 示例：除了最后一个li，其他li添加下划线 li:not(:last-child) { border-bottom: 1px solid red; } 伪元素 匹配首字母 ::first-letter 匹配鼠标选中的文本 ::selection 匹配首行 ::first-line 在节点前面添加 ::before 在节点后面添加 ::after P::first-letter { font-size: 40px; color: red; } p::first-line { background: white; color: teal; } P::before { content: &#39;文章开始了：&#39;; } P::after { content: &quot;结束啦...&quot; } P::selection { color: tomato; background: none; } 属性选择器| 选择符 | 版本 | 描述 || ————– | ——– | ———————————————————— || E[att] | CSS2 | 选择具有att属性的E元素。 || E[att=”val”] | CSS2 | 选择具有att属性且属性值等于val的E元素。 || E[att~=”val”] | CSS2 | 选择具有att属性且属性值为一个用空格分隔的字词列表，其中一个等于val的E元素。 || E[att^=”val”] | CSS3 | 选择具有att属性且属性值为以val\\开头**的字符串的E元素。 || E[att$=”val”] | CSS3 | 选择具有att属性且属性值为以val\\结尾**的字符串的E元素。 || E[att*=”val”] | CSS3 | 选择具有att属性且属性值为包含val的字符串的E元素。 || E[att|=”val”] | CSS2 | 选择具有att属性且属性值为以val开头并用连接符”-“分隔的字符串的E元素，如果属性值仅为val，也将被选择。 | H5中的Flex布局与字体图标关键词理解【重点】 容器container—–大盒子 项目item—–小盒子 主轴—–默认：水平线—–方向：从左到右 侧轴—–默认：垂直线—–方向：从上到下 主轴起点—–主轴与容器相交的第一个点位 主轴终点—–主轴与容器相交的最后一个点位 侧轴起点—–侧轴与容器相交的第一个点位 侧轴终点—–侧轴与容器相交的最后一个点位 flex布局用法【重点】声明盒子为flex容器 display：flex； 容器属性 flex-direction 设置主轴及主轴方向 row 水平向右 column 垂直向下 justify-content 设置项目的主轴对齐方式 center 以主轴进行居中对齐 flex-start 以主轴起点对齐 flex-end 以主轴终点对齐 space-around 环绕对齐 space-between 两端对齐 align-items 设置项目的侧轴对齐方式 center 以侧轴进行居中对齐 flex-start 以侧轴起点对齐 flex-end 以侧轴终点对齐 flex-wrap 是否换行 wrap 换行 nowrap 不换行 align-content 多行侧轴对齐方式 flex-start 以侧轴起点对齐 flex-end 以侧轴终点对齐 center 以侧轴 居中对齐 space-around 以侧轴 环绕对齐 space-between 以侧轴 两端对齐 项目属性 order 作用：设置项目的出场顺序，根据order的值 的大小进行从小到大出场。 0 默认 负整数/正整数 flex 作用：设置项目的放大倍数，缩小倍数，固定大小 1 放大倍数 缩小倍数(1) 放大：1 填充所有 0：不放大 缩小：1 减掉溢出部分的平分值 0：不缩小 固定值： 500px 布局案列分析 html, body { width: 100%; height: 100%; } body { display: flex; flex-direction: column; } * { padding: 0; margin: 0; } header { height: 70px; background-color: red; } main { flex: 1; overflow-y: scroll; } footer { height: 70px; background-color: chocolate; } iconfont字体图标库的使用 登录iconfont 阿里巴巴矢量图标库 官网 创建项目【资源管理—我的项目—-新建项目（找到有+图标的地方点击）】 填写项目名称—点击新建 将购物车中的图标 添加到 刚才创建的项目中 线上使用方法 特点：必须联网才可以使用 font class 查看在线链接 复制在线链接 在html文件中link标签进行引入 &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/font_2586778_aik4zwni6ft.css&quot;&gt; &lt;i class=&quot;iconfont icon-dianzan&quot;&gt;&lt;/i&gt; 离线本地使用方法 特点：可以在没有外网的环境中使用 点击下载到本地 解压后复制所有的字体文件+iconfont.css 将复制的文件放到项目中 html页面中link标签引入iconfont.css文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont/iconfont.css&quot;&gt; &lt;i class=&quot;iconfont icon-dianzan&quot;&gt;&lt;/i&gt; transition过渡效果【重点】transition：变化的属性/all 过渡效果时长 快慢曲线 延时时长 案列 div { width: 50px; height: 50px; background-color: darkcyan; transition: all 5s ease-in-out 2s; } div:hover { width: 500px; } H5变形、动画渐变线性渐变 用法 background:linear-gradient(角度/to 方向, 颜色1,颜色2，颜色3,....) 示例 background: linear-gradient(to right top, red, green); background: linear-gradient(-145deg, red, green, #f60); 径向渐变 用法 background: radial-gradient(颜色1, 颜色2, 颜色3,...); 重复线性渐变 background:repeating-linear-gradient(颜色1 10%,颜色2 10%，颜色3 10%,....) background: repeating-linear-gradient(red, yellow 10%, green 20%); 重复径向渐变 background: repeating-radial-gradient(颜色1 10%,颜色2 10%，颜色3 10%,....); background: repeating-radial-gradient(red, yellow 10%, green 15%); 变形transform【重点】缩放scale（） 作用：缩小或者放大 说明：x：x轴放大缩小倍数 y：y轴放大缩小倍数 取值范围：1 放大 transform:scale(x,y) // 如果只写了一个参数 同比放大缩 小 transform:scaleX(x) transform:scaleY(y) 平移translate（） 作用：对盒子移动 说明：x：x轴平移距离 y：y轴平移距离 取值范围： -100px 100px transform:translate(x,y) // 如果只写了一个参数 只有x轴移动 transform:translateX(x) transform:translateY(y) 翻转旋转rotate（） 作用：盒子翻转、旋转 翻转 /*x轴翻转*/ transform: rotateX(90deg); /*y轴翻转*/ transform: rotateY(180deg); 旋转 /* z轴旋转 */ transform: rotate(360deg); transform: rotateZ(360deg); 斜切（了解）skew（） 作用：斜切、倾斜、扭曲 说明：x：x轴的斜切角度 y：y轴的斜切角度 skew(x，y) skewX(x) skewY(y) ransform: skew(45deg, 45deg); 设置原点 transform-origin 写到受影响的盒子上 参数说明：盒子点位（9个）默认：center center left top right bottom 100px 100px (向右100px 向下100px 作为原点) transform-origin: right bottom; transform-origin: top center; transform-origin: -20px 30px; 动画【重点】 示例 /*定义动画*/ @keyframes run { /*开始*/ from { transform: translateX(0) rotate(0); } /*结束*/ to { transform: translateX(300px) rotate(480deg); } } .box{ /*使用动画*/ animation: run 2s; } 动画属性 animation：参数 参数1 动画名字 【必须】 [ animation-name] 参数2 动画时长 【必须】[animation-duration ] 参数3 动画执行快慢曲线 【可选】 [animation-timing-function ]] linear： 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease： 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) ease-in： 由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out： 由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out： 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) 参数4 循环次数 【可选】 [animation-iteration-count ] 数字（小数）正数 infinite 无限次 参数5 延迟执行时间 【可选】 [animation-delay ] 参数6 是否反向运动 【可选】[ animation-direction] alternate 反向 normal 不反向 参数7 动画停止状态 【可选】 [animation-fill-mode] forwards： 设置对象状态为动画结束时的状态 backwards： 设置对象状态为动画开始时的状态 参数8 动画播放/停止状态 切换 【可选】 [animation-play-state] paused 停止播放 running 开始播放 动画属性案例 点击盒子再开始执行动画 animation: run 1s 10 alternate forwards paused; let box = document.querySelector(&#39;.box&#39;); box.addEventListener(&#39;click&#39;, function () { box.style.animationPlayState = &#39;running&#39;; }) let box = document.querySelector(&#39;.box&#39;); box.addEventListener(&#39;click&#39;, function () { //1.判断 执行的状态 空 || paused //如果是 空 paused 改为running //2.如果是running 改为paused if (box.style.animationPlayState != &#39;running&#39;) { box.style.animationPlayState = &#39;running&#39;; } else { box.style.animationPlayState = &#39;paused&#39;; } })","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"H5","slug":"H5","permalink":"/tags/H5/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Javascript","slug":"Js高阶","date":"2021-02-02T00:31:51.000Z","updated":"2021-07-25T19:28:07.004Z","comments":true,"path":"2021/02/02/Js高阶/","link":"","permalink":"/2021/02/02/Js高阶/","excerpt":"","text":"高阶Js:作用域、函数与闭包执行环境 js代码的执行环境—–执行上下文 js执行栈的数据写入及清除—【先进后出】原则 栈溢出：递归函数大量写入数据 作用域作用域分类 全局作用域 ES5 局部作用域 ES5 块级作用域 ES6新增 {} 作用域的概念【重点】作用域：标识符的作用范围标识符：变量 函数名 函数的参数 对象属性 作用域链【重点】 作用域链查找规则—就近原则 查找方式:逐级向上查找，直到window,最后都没有找到报错。 先在自己的作用域查找这个变量，没有找到 上一级查找这个变量，直到找到window作用域，最后都没找到报错。 区分ES5 与ES6的作用域//ES5 for (var i = 0; i &lt; 5; i++) { console.log(i); //0 1 2 3 4 } console.log(i); // 5 //ES6 for (let i = 0; i &lt; 5; i++) { console.log(i); //0 1 2 3 4 } console.log(i); //i is not defined 函数【重点】ES5函数复习 函数定义 声明式 表达式 函数参数 调用方（实参） 被调用方（形参） 函数必须要有return 被调函数 没有写return ，会自动返回 undefiend 回调函数接收异步返回数据 现在不调，回头再调【满足特定条件 调用】 多个回调函数嵌套使用，会导致：回调地狱， Promise() ES5函数的默认参数 arguments 伪数组 函数的形参默认值的设置 a=a||0; //ES5 function(a=0){} //ES6 函数的调用 ES6箭头函数【重点】 去掉function ，小括号与大括号之间加上 “=&gt;” 如果形参只有一个可以省略小括号 如果没有形参，小括号必须保留 如果函数体中只有一句代码，可以省略 return 与 大括号 //ES6 求和 // let fn = (a, b) =&gt; a + b; // console.log(fn(100, 2)); let arr = [1, 2, 1, 45, 4, 54, 854]; //map let arr1 = arr.map(item =&gt; item + 100) // forEach filter sum() findIndex find ES5 默认参数arguments function fn() { if (arguments.length == 1) { return arguments[0]; } if (arguments.length == 2) { return arguments[0] + arguments[1]; } if (arguments.length == 3) { return (arguments[0] + arguments[1] + arguments[2]) / 3; } if (arguments.length == 4) { let arr = []; for (var i = 0; i &lt; arguments.length; i++) { arr.push(arguments[i]); } return arr; } } ES6的函数默认参数 ES6函数 没有了arguments，ES6新增了rest参数 ES6函数 没有了this指向 ES6 rest参数【重点】…data data:所有实参数据集合，真数组 //1.将所有的实参全部存到一个数组里面 const sum = (...arr) =&gt; { console.log(arr); arr.forEach(item =&gt; console.log(item)) } sum(1, 2, 15, 45, 45, 45, 454, 85, 8, 78, 8, 7, 8, 87874) //2.将部分实参存到数组里面 const sum = (user1, user2, user3, ...arr) =&gt; { console.log(user2); console.log(arr); } sum(&#39;张麻子&#39;, &#39;黄四郎&#39;, &#39;师爷&#39;, 1, 4, 54, 54, 5, 48, 7878, 7, 87, 87, 8, 78) ES5的立即执行函数 IIFE 概念：一旦加载js文件立即执行该函数体的代码，一般一个页面只会写一个立即执行函数 ;(function(){ 函数体 })() 闭包【重点】闭包的概念 函数内部变量跨作用域访问 闭包的作用 保护局部变量不被全局污染；形成块级作用域 闭包常见写法外部函数包含内部函数，外部函数返回内部函数function fn(){ var a=1000; return function(){ a-=100; } } let fn1 = fn(); fn1() 外部函数包含内部函数，内部函数挂载到window;(function(){ var a=1000; window.output = function(){ a-=100; } })() output() 案列//压岁钱模型 function mom() { var money = 500; return function () { money -= 100; console.log(money); } } var spendMoney = mom(); spendMoney(); //根据闭包实现一个取号器 function num(){ var num = 0; let add =function(){ num++; cosnole.log(num) } return add; } var numAdd = num(); function newAdd(){ num =1; console.log(num) } 闭包应用解决定时器问题 通过闭包实现一个ES6才有的代码块区域（ES6块级作用域） 定时器问题 for (var i = 0; i &lt; 5; i++) { setTimeout(function () { console.log(i); }, 1000) } //过了1S 瞬间打印 5个5 //ES5 块级作用域 for (var i = 0; i &lt; 5; i++) { ; (function (index) { setTimeout(function () { console.log(index); }, 1000) })(i) } //过了1S 瞬间打印 0 1 2 3 4 多个li选择器事件触发问题&lt;li&gt;菜单1&lt;/li&gt; &lt;li&gt;菜单12&lt;/li&gt; &lt;li&gt;菜单13&lt;/li&gt; &lt;li&gt;菜单14&lt;/li&gt; &lt;li&gt;菜单15&lt;/li&gt; &lt;li&gt;菜单16&lt;/li&gt; &lt;li&gt;菜单17&lt;/li&gt; &lt;li&gt;菜单18&lt;/li&gt; &lt;script&gt; var lis = document.querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { ; (function (i) { lis[i].addEventListener(&#39;click&#39;, function (ev) { console.log(i); }) })(i) } &lt;/script&gt; ES6实现闭包ES6 直接通过 let 关键字 直接形成ES5闭包（块级作用域） //解决事件监听的问题 let lis = document.querySelectorAll(&#39;li&#39;); for (let i = 0; i &lt; lis.length; i++) { lis[i].addEventListener(&#39;click&#39;, function (ev) { console.log(i); }) } //解决定时器问题 for (let i = 0; i &lt; 5; i++) { setTimeout(function () { console.log(i); }, 1000) } 高阶Js对象、构造函数、原型链、this指向面向对象及面向过程面向对象 更加注重事情结果 面向过程 更加注重0-1,从无到有的发展 类与对象类 具有相同属性的事物，抽象概念 对象 具体的事物，具象化 对象创建对象实例化let obj = new Object(); 字面量(实例化的语法糖)let obj = {} 【注意】如果需要批量创建对象，工厂模式 工厂函数实现批量创建对象 /*批量 狗的对象*/ function createObj(name, age, sex) { let obj = {}; obj.name = name; obj.age = age; obj.sex = sex; obj.eat = function () { console.log(&#39;干饭....&#39;); } return obj; } let obj = createObj(&#39;哮天犬&#39;, 500, &#39;公&#39;); let obj1 = createObj(&#39;小黄&#39;, 2, &#39;母&#39;); let obj2 = createObj(&#39;旺财&#39;, 7, &#39;母&#39;); /*汽车的工厂函数*/ function createCar(pp, color, price, type) { return { pp, color, price, type, run: function () { console.log(&#39;92的油就可以跑.....&#39;); } } } let hq = createCar(&#39;红旗&#39;, &#39;黑色&#39;, 45, &#39;suv&#39;); let ca = createCar(&#39;长安&#39;, &#39;白色&#39;, 15, &#39;suv&#39;); let jl = createCar(&#39;吉利&#39;, &#39;白色&#39;, 15, &#39;轿车&#39;); 工厂函数的问题：批量创建的对象,分类出现错误 构造函数【重点】 没有return 函数中的属性和方法都挂载到this上 命名规则 大驼峰 所有的对象都是通过 构造函数 实例化出来的（new） function ChinaCar(pp, color, price, type) { this.pp = pp; this.color = color; this.price = price; this.type = type; this.run = function () { console.log(&#39;跑....&#39;); } } //实例对象 let hq = new ChinaCar(&#39;红旗&#39;, &#39;黑色&#39;, 45, &#39;suv&#39;) //练习dog 的构造函数 function Dog(name, age, sex, color, type) { this.name = name; this.age = age; this.sex = sex; this.color = color; this.type = type; this.eat = function () { console.log(&#39;干饭....&#39;); } } //实例对象 let dog1 = new Dog(&#39;哮天犬&#39;, 500, &#39;公&#39;, &#39;黑色&#39;, &#39;中华田园犬&#39;) 构造函数的问题：当实例创建过多，实例的方法会不断的挂载到执行栈，方法过载–[原型及原型链解决这个问题] new 关键字【重点】 创建一个空对象 空对象与this进行绑定 将所有的属性和方法指向这个this 实例化时 将实例对象返回出去 原型与原型链【重点】 每个构造函数都有一个显示原型(prototype) 实例对象都有一个隐式原型__proto__ 实例对象的 __proto__指向自己的构造函数的prototype 构造函数的显示原型prototype有一个constructor 指向构造函数自己 原型链【重点】 每个构造函数都有 prototype 这个prototype 是一个对象 ===》 （Object 构造函数实例化出来的） 方法查找：就近原则，逐级往上查找，直到Object，报错 原型方法解决方法过载的问题【重点】 //类 //构造函数 function ChinaCar(pp, color, price, type) { this.pp = pp; this.color = color; this.price = price; this.type = type; // this.run = function () { // console.log(&#39;跑....&#39;); // } } //将所以的方法写显示原型上面 ChinaCar.prototype.run = function () { console.log(&#39;跑....&#39;); } //类的实例对象 let hq = new ChinaCar(&#39;红旗&#39;, &#39;黑色&#39;, 45, &#39;suv&#39;) let ca = new ChinaCar(&#39;长安&#39;, &#39;黑色&#39;, 45, &#39;suv&#39;) 原型链查找变量与方法【重点】 方法查找：就近原则，逐级往上查找，直到Object，没有找到报错 //给Object 添加原型方法或者变量 Object.prototype.say = function () { console.log(&#39;我正在说话...&#39;); } Object.prototype.xxx = &#39;杀得好萨贝达挥洒&#39; //类 //构造函数 function ChinaCar(pp, color, price, type) { this.pp = pp; this.color = color; this.price = price; this.type = type; // this.run = function () { // console.log(&#39;跑....&#39;); // } } //将所以的方法写显示原型上面 ChinaCar.prototype.run = function () { console.log(&#39;跑....&#39;); } //类的实例对象 let hq = new ChinaCar(&#39;红旗&#39;, &#39;黑色&#39;, 45, &#39;suv&#39;) //原型链的方法查找 console.log(hq.say()); console.log(hq.xxx); 给数组的原型添加方法：传递一个元素，能够返回数组元素对应的索引值 let arr = [1,24,15,45,45,45,5] arr.searchIndex(15) // 2 Array.prototype.searchIndex = function (num) { console.log(this); let index = -1; for (let i = 0; i &lt; this.length; i++) { if (num === this[i]) { index = i; break; } } return index; } this指向【重点】 js全局下的this —-window 构造函数中的this —- 实例化出来的对象 事件触发函数中的this—-事件源 箭头函数中的this ——上一级的this 定时器延时器下的this—–window 一般函数的this—谁调用指向谁 对象函数的this—谁调用指向谁 this 借用【重点】 call apply bind 借用的同时 立即调用借出对象.call(借给谁,参数1,参数1,参数1,参数1,参数1,参数1...) 借出对象.apply(借给谁,[参数1,参数1,参数1,参数1,参数1,参数1...]) //借用其他对象中的方法 let obj = { name: &#39;张萨摩&#39;, show: function (a = &#39;&#39;, x = &#39;&#39;) { console.log(a); console.log(this); console.log(&#39;跳舞...&#39;); } } let obj1 = { name: &#39;李四&#39; } //this 借用 // call() apply() bind() // 语法规则： // 借出的对象.借出的方法.call(借给谁,&#39;aaa&#39;,&#39;xxxx&#39;) //立即调用 // obj.show.call(obj1, &#39;李四&#39;) // obj.show.apply(obj1, [&#39;李四&#39;, &#39;sdsad&#39;]) 永久借用let fn =借出的对象.bind(借给谁,参数1,参数1,参数1,参数1,参数1,参数1...) //永久借用 let fn = obj.show.bind(obj1, &#39;李四&#39;); fn() fn() 高阶Js变量内存分配、深浅拷贝、继承、变量类型变量的内存分配变量的储存基本类型 存储到栈内存 引用类型 它的地址存储在栈内存中，数据存储在堆内存中。通过地址(指针)链接起来 变量的拷贝基本类型 变量的拷贝只是拷贝值 引用类型 变量的拷贝拷贝的是地址。存在数据共享问题 变量的传递基本类型 传递的只是值 引用类型 传递的是地址，存在数据共享问题 变量的深浅拷贝浅拷贝for…in…遍历 let user = { name: &#39;张麻子&#39;, age: 30, address: &#39;上海&#39;, } let user1 = {} for (let key in user) { user1[key] = user[key] } user1.name = &#39;倪妮&#39; user1.age = 30 user1.money = 10000000000000000000 user1.address = &#39;我身边&#39; console.log(user) console.log(user1) Object.assgin({},要合并的对象)[注意]第一个参数必须是空对象，这样就得到新的地址 let user = { name: &#39;张麻子&#39;, age: 30, address: &#39;上海&#39;, } let user1 = Object.assign({}, user) user1.money = 100000000000000 console.log(user) console.log(user1) 深拷贝（浅拷贝只能拷贝一层）JSON的2个核心方法（JSON.parse（），JSON.stringify（）） let user = { name: &#39;张三&#39;, age: 40, job: [&#39;扫地&#39;, &#39;洗厕所&#39;], family: { wife: &#39;容嬷嬷&#39;, son: &#39;张武&#39;, }, } let user1 = JSON.parse(JSON.stringify(user)) user1.job.push(&#39;倒水&#39;) user1.family.son = &#39;李五&#39; console.log(user) console.log(user1) lodash解决深拷贝缺陷//使用lodash里面的方法可以解决深拷贝问题 &lt;script src=&quot;./lodash.js&quot;&gt;&lt;/script&gt; &lt;script&gt; let user = { name: &#39;张三&#39;, age: 40, job: [&#39;扫地&#39;, &#39;洗厕所&#39;], family: { wife: &#39;容嬷嬷&#39;, son: &#39;张武&#39;, }, a: NaN,//使用JSON的两个核心方法会缺失 b: Infinity, c: undefined, d: function () {}, } // let user1 = JSON.parse(JSON.stringify(user)) let user1 = _.cloneDeep(user) user1.job.push(&#39;倒水&#39;) user1.family.son = &#39;李五&#39; console.log(user) console.log(user1) &lt;/script&gt; 检测变量类型typeof【5个】 number—–数字类型 字符串转数字 &#39;100&#39;*1 +&#39;100&#39; // 0+&#39;100&#39; undefind—–未定义 boolean—–true/flase string—–字符串类型 数字转字符串 100+&#39;&#39; function—–函数 布尔类型转换结果为flase 0 0.0 ‘’ undefined NaN instanceof 用于检测变量是否是引用类型(构造函数、引用类型、对于Object都是true) console.log([] instanceof Array) //true console.log([] instanceof Object) //true console.log(new Date() instanceof Date) //true console.log(new Date() instanceof Object) //true // &quot;dfdsfd&quot; new String(&quot;dfdsfd&quot;) //flase //100 new Number(100) //flase console.log(Array.isArray([])) //true console.log(Array.isArray({})) //flase Array.isArray【区分数组和对象】 作用：判断是否是一个数组 function each(obj) { if (Array.isArray(obj)) { obj.forEach((item, index) =&gt; console.log(index, &#39;===&gt;&#39;, item)) } else if (obj instanceof Object) { for (let key in obj) { console.log(key, &#39;----&#39;, obj[key]) } } else { console.log(&#39;你是傻子吗？&#39;) } } each([1, 2, 3, 4, 5]) each({ name: &#39;周杰伦&#39;, age: 40, skill: &#39;唱歌&#39; }) each(&#39;ssssssss&#39;) //输出结果 0 &quot;===&gt;&quot; 1 1 &quot;===&gt;&quot; 2 2 &quot;===&gt;&quot; 3 3 &quot;===&gt;&quot; 4 4 &quot;===&gt;&quot; 5 name ---- 周杰伦 age ---- 40 skill ---- 唱歌 你是傻子吗？ Object.prototype.toString.call() 万能检测数据类型 Object.prototype.toString.call() console.log(Object.prototype.toString.call(&#39;aaaa&#39;)) console.log(Object.prototype.toString.call(1234)) console.log(Object.prototype.toString.call(null)) console.log(Object.prototype.toString.call({ name: &#39;张三&#39;, age: 40 })) console.log(Object.prototype.toString.call([1, 23, 12, 312])) console.log(Object.prototype.toString.call(function () {})) ES5的继承【重点】子类继承父类的属性注意子类要继承父类的属性要改变this的指向（call()，apply()） //借用父类属性 Prosen.call(this,name,age) 子类继承父类原型上的方法Student.prototype = Object.create(Prosen.prototype); 子类将constructor 指向构造函数自己 Student.prototype.constructor = Student; 子类在自己的原型上添加自己的方法Student.prototype.study = ()=&gt;console.log(&#39;天天学习&#39;) ES5继承完成示例 //人类 function Prosen(name,age){ this.name = name ; this.age = age ; } Prosen.prototype.eat = function(){ console.log(&#39;吃东西&#39;) } //学生类 function Student(name,age,sno){ //1.子类集成父类的属性 借用父类的属性 call Prosen.call(this,name,age) // this.name = name; // this.age = age; this.sno = sno; } //2.子类集成父类的方法 Student.prototype = Object.create(Prosen.prototype); // 3. 子类的constructor 指向自己 Student.prototype.constructor = Student; //4. Student.prototype.study = function(){ console.log(&#39;天天学习&#39;) } let user = new Prosen(&#39;张麻子&#39;,40) let students = new Student(&#39;小明&#39;,15,&#39;学001&#39;); 高阶JsES6的class类、模块化、语法糖解构（数组、对象、数组参数，函数参数）数组的解构赋值 // 数组的解构 time = [2021, 6, 29] let [y, m, d] = time console.log(y, m, d)//2021 6 29 time = [2021, 6] let [y, m, d = 30] = time console.log(y, m, d)//2021 6 30 time = [2021, 6] let [y, m, d] = time console.log(y, m, d) //2021 6 undefined time = [2021, 6, 31] let [y, m, d = 30] = time console.log(y, m, d) //2021 6 31 对象的解构赋值 // 对象的解构 let user = { name: &#39;彭于晏&#39;, age: 35, addr: &#39;上海&#39;, money: Infinity, } // // let { addr, name, age } = user // console.log(addr, name, age) //上海 彭于晏 35 // let { addr, name, age, money = 1000 } = user // console.log(addr, name, age, money) //上海 彭于晏 35 Infinity let { name, addr, money = 11000 } = user console.log(addr, name, money) //上海 彭于晏 Infinity 函数参数的解构赋值（数组、对象）参数为数组时 const add = ([x, y = 1] = [100]) =&gt; x + y console.log(add()) //101 const add = ([x, y = 1]) =&gt; x + y console.log(add([1, 2])) //3 const add = ([x, y] = [100, 1]) =&gt; x + y console.log(add()) //101 console.log(add([100, 200])) //300 参数为对象时function move({ x = 0, y = 0 } = {}) { return [x, y] } move({ x: 3, y: 8 }) // [3, 8] move({ x: 3 }) // [3, 0] move({}) // [0, 0] move() // [0, 0] 交换两个变量的值 let a = 1; let b = 2; [a, b] = [b, a]; console.log(a, b); //2,1 获取后端数据中需要的数据 const jsonData = { id: 42, status: &#39;OK&#39;, data: [867, 5309], otherData1: 18, otherData2: [&#39;www&#39;, &#39;itsource&#39;, &#39;cn&#39;], otherData3: { a: 1, }, }; let { id, status, data } = jsonData; console.log(id, status, data);//42 &quot;OK&quot; (2) [867, 5309] 展开运算符展开字符串【字符串反转】 let str = &#39;good afternoon&#39; // 展开字符串 console.log(...str) //g o o d a f t e r n o o n //将展开的字符串转为数组 console.log([...str]) //[&quot;g&quot;, &quot;o&quot;, &quot;o&quot;, &quot;d&quot;, &quot; &quot;, &quot;a&quot;, &quot;f&quot;, &quot;t&quot;, &quot;e&quot;, &quot;r&quot;, &quot;n&quot;, &quot;o&quot;, &quot;o&quot;, &quot;n&quot;] //颠倒数组顺序 console.log([...str].reverse()) // [&quot;n&quot;, &quot;o&quot;, &quot;o&quot;, &quot;n&quot;, &quot;r&quot;, &quot;e&quot;, &quot;t&quot;, &quot;f&quot;, &quot;a&quot;, &quot; &quot;, &quot;d&quot;, &quot;o&quot;, &quot;o&quot;, &quot;g&quot;] //将数组转为字符串得到翻转后的字符串 console.log([...str].reverse().join(&#39;&#39;)) //noonretfa doog 展开数组【浅拷贝、数组的合并、伪数组转数组】 let arr = [1, 2, 3, 4, 5] //展开数组 console.log(...arr) //1 2 3 4 5 //实现浅拷贝(将数组展开后再次转化为新数组) console.log([...arr]) //[1, 2, 3, 4, 5] console.log([...arr, ...[1, 3, 5]]) // [1, 2, 3, 4, 5, 1, 3, 5] //伪数组转真数组 function fn() { console.log([...arguments]) //[1, 2, 3, 4, 5] } fn(1, 2, 3, 4, 5) 展开对象【浅拷贝、对象的合并】 let obj = { name: &#39;彭于晏&#39;, age: 40, } //展开对象后再次转换为新对象实现浅拷贝 console.log({ ...obj }) //{name: &quot;彭于晏&quot;, age: 40} //合并对象 console.log({ names: &#39;胡歌&#39;, ages: 20, ...obj }) //{names: &quot;胡歌&quot;, ages: 20, name: &quot;彭于晏&quot;, age: 40} 模板字符串 let emList = [ { id: 1, name: &#39;倪妮&#39;, sex: 1, age: 30, money: 10000000, time: 1324563478889 }, { id: 2, name: &#39;胡歌&#39;, sex: 0, age: 20, money: 20000000, time: 1222222222222 }, { id: 3, name: &#39;陈冠希&#39;, sex: 0, age: 30, money: 30000000, time: 1324943835527 }, { id: 4, name: &#39;佟丽娅&#39;, sex: 1, age: 45, money: 40000000, time: 1424943836627 }, { id: 5, name: &#39;谢霆锋&#39;, sex: 0, age: 50, money: 50000000, time: 1124943837727 }, { id: 6, name: &#39;周杰伦&#39;, sex: 0, age: 10, money: 60000000, time: 1424943838222 }, { id: 7, name: &#39;周杰伦&#39;, sex: 0, age: 10, money: 60000000, time: 1424943838222 }, ]; //将时间戳转换为年月日日期格式 const getDateByTime = (time, sign = &#39;/&#39;) =&gt; { let m = new Date(time).getMonth() + 1; m = m &lt; 10 ? &#39;0&#39; + m : m; let d = new Date(time).getDate(); d = d &lt; 10 ? &#39;0&#39; + d : d; return [new Date(time).getFullYear(), m, d].join(sign); }; let html = &#39;&#39;; //遍历 emList.forEach((item) =&gt; { //模板字符串 html += ` &lt;tr&gt; &lt;td&gt;${item.id}&lt;/td&gt; &lt;td&gt;${item.name}&lt;/td&gt; &lt;td&gt;${item.sex == 0 ? &#39;男&#39; : &#39;女&#39;}&lt;/td&gt; &lt;td&gt;${item.age}&lt;/td&gt; &lt;td&gt;￥ ${item.money.toFixed(2)}&lt;/td&gt; &lt;td&gt;${getDateByTime(item.time)}&lt;/td&gt; &lt;td&gt;&lt;button&gt;删除&lt;/button&gt; &lt;/tr&gt; `; }); document.querySelector(&#39;tbody&#39;).innerHTML = html; 对象的简写 如果key和value一样，只写key 方法省略：function let name = &#39;彭于晏&#39;; let age = 30; let addr = &#39;上海&#39;; let obj = { name, age, addr1: addr, run() {}, eat() {}, }; console.log(obj); //{name: &quot;彭于晏&quot;, age: 30, addr1: &quot;上海&quot;, run: ƒ, eat: ƒ} ES6类（class） 关键字class 类名时大驼峰命名规则 constructor构造器new的时候自动调用相当于构造函数 如果没有写constructor，会自动给你创建一个空的 静态方法只能类去调用，实例对象不能调用，关键字static //类 类名命名大驼峰 class DayStar { //构造器 构造函数 constructor(name, age) { this.nama = name; this.age = age; } //原型上的方法 sing() { console.log(&#39;我爱唱歌&#39;); } move() { console.log(&#39;我爱移动&#39;); } //静态方法 只能类去调用 实例对象不能调用 static eatPerson() { console.log(&#39;我爱你&#39;); } } let pyy = new DayStar(&#39;彭于晏&#39;, 40); console.log(pyy); pyy.sing(); //我爱唱歌 pyy.move(); //我爱移动 DayStar.eatPerson(); //我爱你 ES6类的继承 关键字extends子类extends父类 super() 超类/父类 //类 class Animal { constructor(type, sex, size) { this.type = type; this.sex = sex; this.size = size; } swimming() { console.log(&#39;游泳&#39;); } running() { console.log(&#39;跑跑跑&#39;); } //静态方法 static sleep() { console.log(&#39;睡觉了&#39;); } } class Dog extends Animal { constructor(type, sex, size, color) { //超类 super(type, sex, size); this.color = color; } lookHome() { console.log(&#39;我要看家了&#39;); } static call() { console.log(&#39;giaogiaogiao&#39;); } } let cc = new Dog(&#39;柴犬&#39;, &#39;公&#39;, &#39;小狗&#39;, &#39;黄色&#39;); console.log(cc); Dog.call(); //giaogiaogiao cc.lookHome(); //我要看家了 cc.swimming(); //游泳 cc.running(); //跑跑跑 Animal.sleep(); //睡觉了 ES6模块化模块的定义 一个js文件就是一个模块，放js文件的文件夹就是包 语法一 导出、暴露 export 要暴露的东西 export 要暴露的东西 导入 import {xxx,yyy} from ‘路径/文件名’ 暴露（导出）export let num = 1000; export const getSum = (a, b) =&gt; a + b; export let arr = [1, 2, 3, 4, 5]; export let user = { name: &#39;彭于晏&#39;, age: 30 }; 导入//导入 import { num, arr, user, getSum } from &#39;./fn.js&#39;; console.log(num); //1000 console.log(arr); // [1, 2, 3, 4, 5] console.log(user); //{name: &quot;彭于晏&quot;, age: 30} console.log(getSum(500, 200)); //700 语法二 暴露、导出 export default { ​ 要暴露的东西， ​ 要暴露的东西 } 导入 import 变量名 from ‘路径/文件名’ 调用 变量名.已经暴露的东西 暴露（导出）const getSum = (a, b) =&gt; a + b; const arr = [1, 2, 3, 4, 5, [6, 7, 8]]; const user = { name: &#39;陈冠希&#39;, age: 20 }; export default { getSum, arr, user, }; 导入import myApi from &#39;./b.js&#39;; console.log(myApi); console.log(myApi.getSum(100, 122)); console.log(myApi.user); 高阶Js异步同步处理【Promise】同步异步的概念 同步和异步同时存在，先走完同步，再走异步 console.log(1); setTimeout(() =&gt; console.log(2), 2000); console.log(3); 定时器、事件处理函数、ajax、回调函数 console.log(1); console.log(3); 回调地狱 &lt;script src=&quot;./http.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //请求a.json得到id $http.get(&#39;./serve/a.json&#39;, (res) =&gt; { // let id = res.id let { id } = res; //携带id请求b.json得到code $http.get(&#39;./serve//b.json&#39;, (res) =&gt; { let { code } = res; //携带code请求c.json得到data $http.get(&#39;./serve/c.json&#39;, (res) =&gt; { let { data } = res; console.log(data); ....... }); }); }); &lt;/script&gt; Promise【重点】概念 Promise是构造函数，得到实例对象需要 new Promise() 有三个状态：进行中，成功，失败 状态切换只有两个可能，而且状态改变后不可逆，状态完成就凝固了 进行中—&gt;成功 进行中—&gt;失败 基本语法结构new Primise((resolve,reject)=&gt;{ if(1) { resolve(data) } else { reject(err) } }) .then(data=&gt;{ })//捕获成功 .catch(err=&gt;{ })//捕获失败 Promise解决回调地狱&lt;script src=&quot;./http.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Promise((resolve) =&gt; { //1.请求a.json，得到id $http.get(&#39;./serve/a.json&#39;, (res) =&gt; { resolve(res); }); }).then((data) =&gt; new Promise((resolve) =&gt; { //2.携带id请求b.json，得到code let { id } = data; $http.get(&#39;./serve/b.json?id=&#39; + id, (res) =&gt; { resolve(res); }); }) .then( (data) =&gt; new Promise((resolve) =&gt; { //3.携带code请求c.json，得到data let { code } = data; $http.get(&#39;./serve/c.json?code=&#39; + code, (res) =&gt; { resolve(res); }); }) ) .then((res) =&gt; { let { data } = res; console.log(data); }) ); &lt;/script&gt; Promise完美解决回调地狱&lt;script src=&quot;./http.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //封装一个基于Promise的get请求 const loadData = (url, params = &#39;&#39;) =&gt; new Promise((resolve) =&gt; { url = params === &#39;&#39; ? url : url + &#39;?&#39; + params; //处理参数问题 $http.get(url, res =&gt; resolve(res)); }); //1.请求a.json，得到id loadData(&#39;./serve/a.json&#39;) //2.携带id请求b.json，得到code .then((res) =&gt; loadData(&#39;./serve/b.json&#39;, (&#39;id&#39; + res.id))) //3.携带code请求c.json，得到data .then((res) =&gt; loadData(&#39;./serve/c.json&#39;, (&#39;code&#39; + res.code))) .then((res) =&gt; console.log(res.data)); &lt;/script&gt; axios库的使用【重点】 概念：Axios 是一个基于 promise 的 HTTP 库,可以用在浏览器和 Node.js 中 axios的使用&lt;script src=&quot;./axios.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //get请求 axios.get(&#39;http://139.9.177.51:3333/api/testGet?name=彭于晏&#39;).then(res =&gt; console.log(res.data, new Date().getTime())); axios.get(&#39;http://139.9.177.51:3333/api/testGet&#39;, { params: { name: &#39;金城武&#39; } }).then(res =&gt; console.log(res.data)); //post请求 axios.post(&#39;http://139.9.177.51:3333/api/testPost&#39;, { name: &#39;陈冠希&#39; }).then(res =&gt; console.log(res.data)); &lt;/script&gt; axios解决回调地狱&lt;div&gt;&lt;/div&gt; &lt;script src=&quot;./axios.js&quot;&gt;&lt;/script&gt; &lt;script&gt; axios.get(&#39;./serve/a.json&#39;) .then(res =&gt; axios.get(&#39;./serve/b.json&#39;, { params: { id: res.data.id } })) .then(res =&gt; axios.get(&#39;./serve/c.json&#39;, { params: { code: res.data.code } })) .then(res =&gt; document.querySelector(&#39;div&#39;).innerText = res.data.data) &lt;/script&gt; async和await async异步 只能修饰函数 await和async连用 和Promise连用 示例&lt;script&gt; const timer = () =&gt; new Promise(resolve =&gt; { setTimeout(() =&gt; { console.log(2); resolve(&#39;你快回来&#39;) }, 2000) }) const myApi = async () =&gt; { console.log(1); let res = await timer() console.log(res); console.log(3); } myApi() &lt;/script&gt; async和await解决回调地狱&lt;span style=&quot;font-size: 50px;color: pink;&quot;&gt;&lt;/span&gt; &lt;script src=&quot;./axios.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //axios是基于Promise const loadData = async () =&gt; { //1.请求a.json得到id let data1 = await axios.get(&#39;./serve/a.json&#39;) // console.log(data1); //2.携带id请求b.json得到code let data2 = await axios.get(&#39;./serve/b.json?id=&#39; + data1.data.id) // console.log(data2); let data3 = await axios.get(&#39;./serve/c.json?code=&#39; + data2.data.code) // console.log(data3); //3.携带code请求c.json得到data document.querySelector(&#39;span&#39;).innerText = data3.data.data } loadData() &lt;/script&gt; axios并发请求1.定义请求函数，一定要将axios返回来2.语法结构&lt;script src=&quot;../axios.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //设置axios全局默认服务请求地址 axios.defaults.baseURL = &#39;http://139.9.177.51:3333&#39; //并发请求 一起发送请求 //请求函数 get const getName = () =&gt; axios.get(&#39;/api/testGet&#39;, { params: { name: &#39;金城武&#39; } }) //请求函数 post const getNameTwo = () =&gt; axios.post(&#39;/api/testPost&#39;, { name: &#39;陈冠希&#39; }) const getEmail = () =&gt; axios.post(&#39;/api/emailExist&#39;, { email: &#39;nihaod@qq.com&#39; }) //一起发送请求 axios.all([getName(), getNameTwo(), getEmail()]) .then(axios.spread((dataA, dataB, dataC) =&gt; { console.log(dataA.data); console.log(dataB.data); console.log(dataC.data); })) .catch(error =&gt; console.log(error)) &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"js高阶","slug":"js高阶","permalink":"/tags/js高阶/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Javascript","slug":"Js中阶","date":"2021-01-22T03:01:11.000Z","updated":"2021-07-25T19:27:54.358Z","comments":true,"path":"2021/01/22/Js中阶/","link":"","permalink":"/2021/01/22/Js中阶/","excerpt":"","text":"JS函数与数组进阶ES6定义变量的关键字【重点】var 变量提升 可以重复定义同一个变量 let 先定义再使用 不能在同一作用域下反复定义 形成块级作用域（大括号括起来的就是块级作用域，注意：对象的大括号没有形成块级作用域） const 定义常量 定义必须赋值后面不能修改值 先定义再使用 不能在同一作用域下反复定义 形成块级作用域（大括号括起来的就是块级作用域，注意：对象的大括号没有形成块级作用域） 循环及嵌套循环 输出图形：外层循环控制行，内层循环控制列 读取数据：一层一层读取，一层循环读一维数组，二层循环读二维数组 ….. 字符串的操作【重点】【注意】都不会改变原字符串1.charAt() 作用：返回在指定位置的字符 // 1．charAt 返回在指定位置的字符。 let str = &#39;sdasdasdasfa&#39;; console.log(str.charAt(2)); //a console.log(str); //不改变原字符串 sdasdasdasfa 2.charCodeAt() 作用：返回在指定的位置的字符的 Unicode 编码 // 2．charCodeAt 返回在指定的位置的字符的 Unicode 编码。 let str = &#39;abcdefg&#39;; console.log(str.charCodeAt(2)); //99 console.log(str); //不改变原字符串 abcdefg 3.concat() 作用：连接两个或更多字符串，并返回新的字符串 // 3．concat 连接两个或更多字符串，并返回新的字符串。 let str = &#39;aaaaa&#39;; let str1 = &#39;bbbbb&#39;; console.log(str.concat(str1)); //aaaaabbbbb console.log(str); //aaaaa console.log(str1); //不会改变原字符串 bbbbb 4.includes() 作用：查找字符串中是否包含指定的子字符串 // 4．includes 查找字符串中是否包含指定的子字符串。 let str = &#39;abcdefg&#39;; console.log(str.includes(&#39;c&#39;)); //true 找不到返回false console.log(str); //不会改变原字符串 abcdefg 5.indexOf() 作用：返回某个指定的字符串值在字符串中首次出现的位置 // 5．IndexOf 返回某个指定的字符串值在字符串中首次出现的位置。 let str = &#39;abcdefg&#39;; console.log(str.indexOf(&#39;o&#39;)); //2 找不到返回-1 console.log(str); //不会改变原字符串 abcdefg 6.replace() 作用：在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串 // 6．replace 在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串 let str = &#39;abcdefg&#39;; console.log(str.replace(&#39;a&#39;, &#39;o&#39;)); //obcdefg console.log(str); //不会改变原字符串 abcdefg 7.slice() 作用：提取字符串的片断，并在新的字符串中返回被提取的部分 // 7．slice 提取字符串的片断，并在新的字符串中返回被提取的部分。 let str = &#39;abcdefg&#39;; console.log(str.slice(2, 6)); //cdef console.log(str); //不会改变原字符串 abcdefg 8.split() 作用：把字符串分割为字符串数组 // 8．split 把字符串分割为字符串数组。 let str = &#39;abcdefg&#39;; console.log([...str]); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;] console.log(str.split(&#39;&#39;)); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;] console.log(str); //不会改变原字符串 abcdefg 9.substr() 作用：从起始索引号提取字符串中指定数目的字符 // 9．substr 从起始索引号提取字符串中指定数目的字符。 let str = &#39;abcdefg&#39;; console.log(str.substr(0, 2)); //ab console.log(str); //不会改变原字符串 abcdefg 10.substring() 作用：提取字符串中两个指定的索引号之间的字符 // 10．substring 提取字符串中两个指定的索引号之间的字符。 let str = &#39;abcdefg&#39;; console.log(str.substring(0, 3)); //abc console.log(str); //不会改变原字符串 abcdefg 11.toLowerCase() 作用：把字符串转换为小写 // 11．toLowerCase 把字符串转换为小写。 let str = &#39;ABCDEFG&#39;; console.log(str.toLowerCase()); //abcdefg console.log(str); //不会改变原字符串 ABCDEFG 12.toUpperCase() 作用：把字符串转换为大写 // 12．toUpperCase 把字符串转换为大写。 let str = &#39;abcdefg&#39;; console.log(str.toUpperCase()); //ABCDEFG console.log(str); //不会改变原字符串 abcdefg 13.trim() 作用：去除字符串两边的空白 // 13．trim 去除字符串两边的空白 let str = &#39; abcdefg &#39;; console.log(str.trim()); //abcdefg console.log(str); //不会改变原字符串 abcdefg 数组的操作【重点】1.push() 作用：向数组的末尾添加一个或更多元素，并返回新的长度 特点：改变原数组 // 1．push 向数组的末尾添加一个或更多元素，并返回新的长度。 let arr = [1, 2, 3, 4] console.log(arr.push(5, 6, 7)) //返回数组的长度 7 console.log(arr) //改变原数组 [1,2,3,4,5,6,7] 2.unshift() 作用：向数组的开头添加一个或更多元素，并返回新的长度 特点：改变原数组 // 2．unshift 向数组的开头添加一个或更多元素，并返回新的长度。 let arr = [123, 3, 123, 12, 4, 12, 412] console.log(arr.unshift(&#39;陈冠希&#39;, &#39;彭于晏&#39;, &#39;胡歌&#39;)) //10 console.log(arr) //改变原数组[&#39;陈冠希&#39;, &#39;彭于晏&#39;, &#39;胡歌&#39;,123, 3, 123, 12, 4, 12, 412] 3.splice() 作用：向数组的开头添加一个或更多元素，并返回新的长度 特点：改变原数组 // 3．splice 从数组中添加或删除元素。 let arr = [312, 3, 12, 3, 1231, 324, 564] arr.splice(1, 0, &#39;你好&#39;, &#39;我不好&#39;) //312, &quot;你好&quot;, &quot;我不好&quot;, 3, 12, 3, 1231, 324, 564 console.log(arr) //[312,&#39;你好&#39;, &#39;我不好&#39;, 3, 12, 3, 1231, 324, 564] arr.splice(2, 3, &#39;你好&#39;, &#39;我不好&#39;) //312, &quot;你好&quot;, &quot;你好&quot;, &quot;我不好&quot;, 3, 1231, 324, 564 console.log(arr) //改变原数组 参数按照长度 4.pop() 作用：向数组的开头添加一个或更多元素，并返回新的长度 特点：改变原数组 // 4．pop 删除数组的最后一个元素并返回删除的元素。 let arr = [1, 2, 3, 4, 5] console.log(arr.pop()) //返回删除的元素 5 console.log(arr) //改变原数组[1, 2, 3, 4] 5.shift() 作用：向数组的开头添加一个或更多元素，并返回新的长度 特点：改变原数组 // 5．shift 删除并返回数组的第一个元素。 let arr = [1, 23, 12, 3, 12] console.log(arr.shift()) //1 console.log(arr) //改变原数组 23,12,3,12 6.forEach() 作用：向数组的开头添加一个或更多元素，并返回新的长度 特点：不改变原数组 // 6．forEach 数组每个元素都执行一次回调函数。 let arr = [1, 2, 3, 4, 5, 6, 7] arr.forEach((item) =&gt; console.log(item + 5))//[6,7,8,9,10,11,12] console.log(arr) //不改变原数组 7.delete() 作用：删除数组中的指定元素 特点：改变原数组 // 7.delete 删除数组中的指定元素会留下空位 let arr = [1, 2, 3, 4, 5, 6, 7] console.log(delete arr[4]) //true console.log(arr) // [1, 2, 3, 4, empty, 6, 7] 8.map（） 作用：遍历数组并返回一个新数组 特点：不影响原数组的值 let arr = [1, 2, 564, 5, 45, 45]; let arr1 = arr.map(function (item) { return item * 2; }) console.log(arr1); //[2, 4, 1128, 10, 90, 90] //将数组中的元素 的某个属性 的值都更改一下 let arr = [ { sno: 1, age: 15, name: &#39;张麻子&#39; }, { sno: 2, age: 20, name: &#39;张麻子&#39; }, { sno: 3, age: 12, name: &#39;张麻子&#39; }, { sno: 4, age: 18, name: &#39;张麻子&#39; }, ] let arr2 = arr.map(function (item) { item.age = item.age + 5; return item; }) console.log(arr2); 9.find() 作用：遍历数组，返回满足条件的第一个元素 特点：不会影响原数组 let arr = [1, 2, 4, 31, 54, 54, 5, 45]; let data = arr.find(function (item) { return item &gt; 30; }) console.log(data); //31 let arr = [ { sno: 1, age: 15, name: &#39;张麻子1&#39; }, { sno: 2, age: 20, name: &#39;张麻子2&#39; }, { sno: 3, age: 12, name: &#39;张麻子3&#39; }, { sno: 4, age: 18, name: &#39;张麻子4&#39; }, ] let data1 = arr.find(function (item) { return item.sno === 3; }) console.log(data1); //{ sno: 3, age: 12, name: &#39;张麻子3&#39; } 10.findIndex() 作用：查找满足条件的第一个元素的索引并返回，找不到返回-1 特点：不改变原数组 let arr = [1, 2, 15, 15, 45, 45, 45, 485]; let index = arr.findIndex(function (item) { return item &gt; 500 }) console.log(index); // -1 11.indexOf() 作用：查找相等的元素的索引并返回，找不到返回-1 特点：不改变原数组 let arr = [1, 2, 15, 15, 45, 45, 45, 485]; let index1 = arr.indexOf(15) console.log(index1); //2 12.join() 作用：将数组转换为字符串，可以添加一个分隔符 特点：不改变原数组 // 数组转字符串 let arr1 = [&#39;张三&#39;, &#39;抽烟 喝酒 烫头&#39;] let str1 = arr1.join(&#39;,&#39;) console.log(str1); //将字符串 转换数组 let arr2 = str1.split(&#39;,&#39;) console.log(arr2); 13.includes() 作用：检测数组中是否包含某个元素，包含返回：true 不包含返回：flase 检测字符串中是否包含某个元素，包含返回：true 不包含返回：flase 特点：不改变原数组 // 检测数组中是否包含某个元素 let arr = [12, 45, 6, 484, 88, 48, 4]; console.log(12); //true console.log(arr.includes(120)); //false //检测字符串中是否包含 某个字符 let str = &#39;xdsadhsavdghasvdghsadvbh&#39;; console.log(str.includes(&#39;dhs&#39;)); //true console.log(str.includes(&#39;aaaa&#39;)); //false 14.reverse() 作用：将数组反序输出 特点：改变原数组 // 2．reverse 反转数组的元素顺序。 let arr = [1, 2, 3, 4, 5] console.log(arr.reverse())//[5,4,3,2,1] console.log(arr) //改变原数组 [5,4,3,2,1] 15.sort() 作用：对数组中的元素进行排序 特点：改变原数组 元素为字符串时的排序 ASCII码 字符0 48 A 65 a 97 // 注意：字符串与 数字的排序有区别 // 字符串排序 只能是 从小到大 （从大到小 reverse() 实现） // 如果元素是字符串 排序不需要写 function let arr = [&#39;Dxxx&#39;, &#39;Bxxx&#39;, &#39;axxx&#39;, &#39;AAAA&#39;] let arr1 = arr.sort(); console.log(arr1); 元素为数字时的排序 // 如果是数值 排序必须写 function let arr2 = [100, 300, 850, 50, 150]; let arr3 = arr2.sort(function (a, b) { //从小到大排序 // return a - b; //从大到小排序 return b - a; }); console.log(arr3); 16.flat() 作用：拉平数组，将多维数组转换为1维数组 特点：不影响原数组 参数：数字(正整数)[拉平的层数]/infinity：无线层 // 8．flat 嵌套数组转一维数组（如：arr.flat()） let arr = [1, 2, [3, 4, [6, 7, 8, [9, 10]]], 5] console.log(arr.flat(4)) console.log(arr.flat(Infinity)) //1,2,3,4,6,7,8,9,10,5 console.log(arr) //不会改变原数组 17.every() 作用：每一个元素都满足条件时返回true 否则返回flase 特点：不改变原数组 let arr = [10, 12, 45, 45, 48, 748, 78, 748, 48] let bool = arr.every(function (item) { return item &gt; 1; }) console.log(bool); //true 18.some() 作用：只要有一个元素满足条件就返回true 没有元素满足条件返回flase 特点：不改变原数组 let arr = [10, 12, 45, 45, 48, 748, 78, 748, 48] let bool = arr.every(function (item) { return item &gt; 740; }) console.log(bool); //true 19.filter() 作用：将原数组中满足条件的元素组成新数组并返回 特点：不改变原数组 // 18．filter 检测数值元素，并返回符合条件所有元素的数组。 let arr = [1, 2, 3, 4, 5, 6] console.log(arr.filter((item) =&gt; item &gt; 3))//4,5,6 console.log(arr) //不改变原数组 let arr = [ { sno: 1, age: 15, name: &#39;张麻子1&#39; }, { sno: 2, age: 20, name: &#39;张麻子2&#39; }, { sno: 3, age: 12, name: &#39;张麻子3&#39; }, { sno: 4, age: 18, name: &#39;张麻子4&#39; }, ] let arr1 = arr.filter(function (item) { return item.age &gt;= 18; }) console.log(arr1); 20.slice() 作用：截取数组返回新数组 特点：不改变原数组 let arr = [1, 45, 54, 545, 65, 45, 45, 4]; // 左闭右开 //参数：起点索引 终点索引 // let arr1 = arr.slice(1, 5); // console.log(arr1); // 参数：如果参数是 负数， 倒数 let arr2 = arr.slice(-3, -1); console.log(arr2); 21.concat() 作用：连接两个或更多的数组，并返回结果 特点：不改变原数组 // 1．concat 连接两个或更多的数组，并返回结果。 let arr = [1, 2] let arr1 = [3, 4] console.log(arr.concat(arr1)) //[1,2,3,4] console.log(arr) //[1,2] console.log(arr1) //不会改变原数组 [3,4] 小结：按照是否改变原数组 改变原数组： reverse() sort() push() unshift() shift() pop() delete() splice() 按照参数 传递函数：map find findIndex sort(数值排序) every some filter 函数函数的隐藏参数arguments arguments：伪数组（类数组） // 实现任意个参数 进行求和的函数 function sum() { console.log(arguments); //for 循环 let num = 0; for (let i = 0; i &lt; arguments.length; i++) { num += arguments[i]; } return num; } console.log(sum(1, 2, 5, 45, 45, 5)); 函数的形参默认值设置Es5 //形参默认值设置 function sum(a, b) { //ES5 形参默认值设置 a = a || 0; b = b || 0; return a + b; } console.log(sum(100)); 函数提升【重点】 【注意】声明式定义的函数，有函数提升的问题 // sum(); // 声明式定义 可以函数提升 // function sum() { // console.log(&#39;xxxx&#39;); // } sum(); // 表达式定义 没有函数提升 var sum = function () { console.log(&#39;xxxxx&#39;); } ES6中形参的默认值设置 //ES6 直接在形参接收时 设置 默认值 function sum(a = 0, b = 0) { //ES5 // a= a||0 // b=b||0 return a + b; } console.log(sum(10, 20)); 回调函数【重点】 回调函数的作用：现在不调，回头再调 解决问题：异步数据返回 产生问题：回调地狱 函数调用：必须要写return，没有return，会返回undefined // 回调案例 // 现在不调 回头再调 // 实现：3秒之后 计算平均数 function fn(a, b, callback) { let sum = a + b; setTimeout(function () { let num = sum / 2; callback(num); }, 3000) } fn(1, 32, function (res) { console.log(res); }) 递归函数 特点：在函数的内部调用自己 //递归【了解】 // 在函数体中 调用自己（值发生改变） // 应用场景：遍历多级的菜单 function fn(i) { //判断 如果i &lt;1 结束 if (i &gt; 1) { return i * fn(i - 1) } else { return 1; } } console.log(fn(10)); JS对象与BOM进阶对象 【重点】字面量创建 let obj = ｛｝ 实例化创建 let obj = new Object（） 对象方法keys 作用：获取对象中所有的属性名，返回一个数组 语法：Object.keys（obj） let obj = { name: &#39;张麻子&#39;, age: 40, like: [&#39;抽烟&#39;, &#39;喝酒&#39;, &#39;烫头&#39;], } //将所有的属性名 取出来放到数组中 let keyArr = Object.keys(obj); // [&#39;name&#39;,&#39;age&#39;,&#39;like&#39;] //遍历数组 取对象属性的值 keyArr.forEach(function (item) { console.log(obj[item]); }) 对象方法assgin 作用：合并多对象，到一个新的对象中 注意：合并多对象时，如果后面的对象有重复属性，后面的属性值会覆盖前面的属性值 //1.直接合并到obj 中 --改变了obj的值 Object.assign(obj, info); //2.合并到新的 对象中--原对象不会改变 let userInfo = Object.assign({}, obj, info); 内置对象Date 使用：let date = new Date（） /*将格林威治时间 转换为 本地时间格式*/ // 2021-06-06 14:39:30 //年 let y = date.getFullYear(); //月 let m = parseInt(date.getMonth()) + 1; //日 let d = date.getDate(); //小时 let h = date.getHours(); //分钟 let min = date.getMinutes(); //秒 let s = date.getSeconds(); //添 0 补齐 // if (m &lt; 10) { // m = &#39;0&#39; + m // } //三目运算符 添 0 补齐 m = m &lt; 10 ? &#39;0&#39; + m : m; d = d &lt; 10 ? &#39;0&#39; + d : d; h = h &lt; 10 ? &#39;0&#39; + h : h; min = min &lt; 10 ? &#39;0&#39; + min : min; s = s &lt; 10 ? &#39;0&#39; + s : s; let str = `${y}-${m}-${d} ${h}:${min}:${s}`; console.log(str); new Date()传值 new Date(时间戳/字符串（2021-02-01）） toLocalString() 作用：将格林威治时间格式转换为本地字符串形式的时间 用法：new Date().toLoaclString(); getTime() 作用：获取格林威治时间对应的时间戳 用法：new Date().getTime() 特点：13位的数值，永不重复，参与数学运算（+-*/） //获取格林威治时间对应的时间戳 let date1 = date.getTime(); // 13位数字 1970-1-1 // 永不重复 // 优点1：便于推算之前 与 之后的时间 //获取前十天的时间 let date2 = date1 - 24 * 60 * 60 * 1000 * 10; //时间戳转换为 格式 格林威治时间 let date3 = new Date(date2); // console.log(date3.toLocaleString()); //优点2： 计算两个时间戳 间隔的天数 let date4 = new Date(&#39;2021-06-01&#39;).getTime(); let date5 = new Date(&#39;2021-05-01&#39;).getTime(); console.log(date4); console.log(date5); //计算间隔天数 // 两个间隔的总 毫秒数 / 1天的毫秒 === 有多少天 let days = (date4 - date5) / (24 * 60 * 60 * 1000) console.log(days); unix时间戳转换工具 内置对象location【重点】 console.log(location.protocol); //主机地址 console.log(location.hostname); //端口号 console.log(location.port); //数据参数 console.log(location.search); //锚点 console.log(location.hash); /** * @strToObj 将url中地址栏的 search 的数据获取转换为 对象 * @str String url search 的字符串 * @return Object {name:zhangmazi,age:40} */ strToObj: function (str) { let obj = {} //去掉 ? str = str.substr(1); // name=zhangmazi&amp;age=40&amp;sex=nan //字符串转换为数组 let arr = str.split(&#39;&amp;&#39;); //[&quot;name=zhangmazi&quot;, &quot;age=40&quot;, &quot;sex=nan&quot;] //遍历数组 arr.forEach(function (item) { //以 = 分割 形成多个小数组 let arr1 = item.split(&#39;=&#39;); // [&quot;name&quot;, &quot;zhangmazi&quot;] [&quot;age&quot;, &quot;40&quot;] [&quot;sex&quot;, &quot;nan&quot;] // 组装obj obj[arr1[0]] = arr1[1] }) return obj; } location.href 跳转页面 location.href = &#39;http://www.baidu.com&#39; location.reload() 重载/刷新页面 let btn = document.querySelector(&#39;button&#39;); btn.addEventListener(&#39;click&#39;, function () { location.reload(); }) history 作用：网页的历史记录 history.go(2) // 前进2页 history.back() // 后退1页 go(-1) history.forward() // 前进1页 go(1) history.length // 浏览器历史列表中的元素数量 screenscreen.availHeight // 可用的屏幕高度 screen.availWidth // 可用的屏幕宽度 screen.width // 屏幕的宽 screen.height // 屏幕的高 navigatorconsole.log(navigator.userAgent) //用户 客户端 信息 JS正则表达式和事件进阶正则表达式正则的定义实例化let reg = new RegExp(&quot;字符串&quot;,[模式修饰符]) 字面量let reg = / 规则 / 正则的使用reg.test(str) //满足正正则验证 返回：true 不满足返回：false 正则规则 ^ 以….开头 $ 以……结尾 [] 以….范围之内 {} 出现次数 | 或者 标识符 i 不区分大小写 let reg = /w/i 案例示范//手机号 let reg = /^1[3-9][0-9]{9}$/ let str = &#39;22444444444&#39;; console.log(reg.test(str)); //不区分大小写 匹配 let str = &#39;asdasdWsdsaadsadad&#39;; // let reg = /W|w/; let reg = /w/i; console.log(reg.test(str)); //1. 匹配字符串中是否有 &#39;a&#39; //2. 实现手机号 匹配验证 //3. 匹配字符串中 是否出现 * 事件【重点】事件对象event 作用：完整记录事件从发生到结束的整个过程产生的所有数据变化 事件源—–event.target 事件类型—–event.type 键盘事件的键盘码—–event.keyCode 键盘事件 触发的键盘：键码值 键盘事件的监听 inp.addEventListener(&#39;keyup&#39;, function (event) { //按下回车 if (event.keyCode === 13) { console.log(inp.value); } //按下回退键 if (event.keyCode === 8) { console.log(inp.value); } }) 事件流 定义：事件发生的所有过程 事件流的三个阶段 第一阶段：事件捕获，从上之下，依次捕获 第二阶段：自身触发 第三阶段：事件冒泡，从下至上，依次触发 注意 el.addEventListener(&#39;事件类型&#39;,触发执行函数fn,捕获 true/冒泡 false ) 阻止事件传播（捕获/冒泡） 阻止事件传播 event.stopPropagation(); 阻止浏览器的默认行为 let aDom = document.querySelector(&#39;a&#39;); aDom.addEventListener(&#39;click&#39;, function (event) { console.log(&#39;xxx&#39;); //取消浏览器默认行为 event.preventDefault(); }) 事件移除 //点击之后 移除事件 //移除5s之后 又将事件添加回来 let btn = document.querySelector(&#39;button&#39;); let add = function (event) { console.log(&#39;点你了&#39;); //清除事件监听 btn.removeEventListener(&#39;click&#39;, add) // 过5s 添加click 事件的监听 setTimeout(function () { btn.addEventListener(&#39;click&#39;, add) }, 5000) } btn.addEventListener(&#39;click&#39;, add) 事件委派【重点】 概念：将子节点的事件交给父级/祖宗级节点进行监听，实现原理：事件冒泡原理 优点 提升性能，只在内存中存储了一个事件函数。 动态添加的节点，实现事件监听 //事件委派 tody 做监听 tbody.addEventListener(&#39;click&#39;, function (event) { // 根据事件源 判断是否点击了删除 按钮 if (event.target.nodeName === &#39;BUTTON&#39;) { console.log(&#39;点击了删除按钮....&#39;); event.target.parentNode.parentNode.remove(); } }) Ajax原理[重点]ajax基础概念很久以前的开发模式 ajax引擎 ajax get请求-4步 // get请求 4步 //1. 实例化ajax let xhr = new XMLHttpRequest(); //2. 请求方式, 请求地址+请求的数据 xhr.open(&#39;get&#39;, &#39;http://139.9.177.51:3333/api/testGet?name=张麻子&#39;); //3. 监听ajax的状态 及 返回数据 xhr.onreadystatechange = function () { //判断 ajax 状态 if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { //获取返回值 console.log(xhr.responseText); } } //4. 发送请求 xhr.send(); xhr.onreadystatechange 作用：监听ajax 状态变化 每一次变化 都会自动触发 xhr.readyState 作用：ajax 的请求状态，只有到最后一步 readyState===4 才能拿到返回数据 xhr.status 作用：网页请求状态码 200 成功 200-300 问题不大 成功 300-400 静态资源访问路径错误–问题很小 400-500 访问出错，找不到访问地址–问题很大-记得甩锅 500以上 ajax已经进入后端代码， 后端拦截—不关前端的事情 404 not found //找不到路径 403 not found //没有权限访问 501 //拒绝/拦截访问 301 //静态资源路径出错 201 //成功 ajax 4看排错法1看：请求地址+请求方式 2看：http状态码 3看：请求参数 4看：返回参数 ajax post 请求-5步 // post请求 5句代码 //1.实例化ajax let xhr = new XMLHttpRequest(); //2.请求方式 请求地址 xhr.open(&#39;post&#39;, &#39;http://139.9.177.51:3333/api/testPost&#39;); //3.post 请求 修改请求头， 模仿form 表单的 请求 xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); //4.监听返回 xhr.onreadystatechange = function () { //判断步骤 状态码 if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { console.log(xhr.responseText); } } //5.发送+数据 xhr.send(&#39;name=张麻子&amp;age=20&#39;) 数据渲染 let body = document.querySelector(&#39;body&#39;); //4.监听返回 xhr.onreadystatechange = function () { //判断步骤 状态码 if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { //将json数据转换为 js对象 let res = JSON.parse(xhr.responseText); console.log(res); //渲染到页面 let html = `&lt;p&gt;${res.msg}&lt;/p&gt; &lt;p&gt;${res.data}&lt;/p&gt;`; body.innerHTML = html; } } json文件请求//2. 请求方式, 请求地址+请求的数据 xhr.open(&#39;get&#39;, &#39;./data.json&#39;); post请求传输json数据xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); let data = { account: &#39;17111111111&#39;, password: &#39;123456&#39; } //5.发送+数据 xhr.send(JSON.stringify(data))","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"js中阶","slug":"js中阶","permalink":"/tags/js中阶/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Javascript","slug":"Js初阶","date":"2020-12-30T06:05:55.000Z","updated":"2021-07-25T19:27:38.502Z","comments":true,"path":"2020/12/30/Js初阶/","link":"","permalink":"/2020/12/30/Js初阶/","excerpt":"","text":"JavaScript的基础语法JavaScript的组成部分（面试题） 三个组成部分 ECMAScript—–js语法基础 BOM—–js操作浏览器的功能 DOM—–js操作html文件中所有的标签，超文本和css样式（DOM是BOM中的一个小部分) JavaScript中的四种使用方式与三种输出方式 三种输出方式 alert(‘文字内容’)；—–浏览器警告弹窗 document.write(‘写入body标签中的内容’) console.log(‘要打印的内容’)—–在开发者后台的console功能下查看打印结果【重要】 功能：打印后台获取的数据，使用它打印过程量来检查代码的bug 四种使用方式 a标签使用 语法结构：&lt;a href=&quot;javascript:alert(&#39;警告内容&#39;)&quot;&gt;文字内容&lt;/a&gt; 内嵌式的操作 语法结构：&lt;div onclick=&quot;alert(&#39;警告内容&#39;)&quot;&gt;内容&lt;/div&gt; 内部式的操作 1.在&lt;/body&gt;上面创建一对&lt;script&gt;&lt;/script&gt; 2.在script中书写js代码 给标签赋予点击事件的操作步骤： 3.获取要点击的标签元素 4.设置点击事件并添加事件函数 外链式的操作【重点】1.创建一个后缀名为js的文件 2.把写在script中的内容写入到js文件中 3.在html文件的&lt;/body&gt;上使用&lt;script src=&quot;文件路径&quot;&gt;&lt;/script&gt; 变量的设置，赋值与定义，并且区别Es5与Es6语法的区别 变量的定义：从document中获取的内容要保存在变量中使用，从数据库中获得的数据要放在变量中用于页面显示操作 定义变量的操作 Es5 关键字：var 标识符：你给变量取的名字 语法结构—–重点 var 变量名 [注意] 定义了变量没有赋值前，打印的内容一定是undefined（没有装任何数据—未定义数据类型） XX is not defined—–这个变量（XX）没有定义 ‘XX’ has already been declared—es6中变量重复定义报错 赋值操作 语法结构—–重点 var 变量名 = 变量值 结论—–【重点】 变量可以重新定义 变量可以重新赋值 Es6 关键字：let 标识符：你给变量取的名字 语法结构—–重点 let 变量名 = 变量值 结论—–【重点】 变量不能重新定义 变量可以重新赋值 常量 const 定义的时候必须赋值 不能重新定义 不能重新赋值 数据归类，数据的基本数据类型基本数据类型—–【重点】 String—–带引号的数据 Number—–所有的数字 undefined—–未定义数据类型 null—–空类型 boolean—–布尔类型（true，false） symbol—–唯一类型（Es6） 检测数据类型的方法：typeof 变量名 复合数据类型（引用数据类型） 函数，对象，数组 数据类型的自动与强制转换字符串类型转数字—–重点 parseInt（变量名）—–整数转换 parseFloat（变量名）—–小数转换 重点运算符的认识算数运算符—–重点 %—–默（取余） ++—–自身+1 放在变量名的前面或后面运算顺序不同 前面（左边）：先自己+1在处理其他运算 后面（右边）：先处理其他运算在自己+1 赋值运算—–重点 +=公式：a = a+ba+=b 条件运算符【注意】这些运算符号都只能使用在条件判断语句的小括号中 &lt;&gt; &gt;= &lt;= == != ！非 重点掌握：=== 全等 !== 不全等 【总结】== 只会比较变量的值，不会比较变量的类型,=== 不但要比较变量的值，还要比较变量类型 &amp;&amp; 并且（与）有多个条并且要全部满足|| 或者（或）有多个条件，只要有一个满足 JavaScript流程控制语句if条件分支语句的使用 程序的运行的运行顺序：从上到下依次运行 条件分支运行 循环运行 if—–如果（条件判定）—–执行不同操作 单分支语句—–只有一个条件，满足就执行相关代码，否则不管语法结构：--(重点) if (判断条件) { 满足条件执行的代码块 } 双分支语句—–只有一个条件，满足执行满足的条件代码，不满足执行不满足的条件代码语法结构：---（重点） if （判断条件） { 满足条件执行的代码块 } else { 不满足条件执行的代码块 } 三目运算：判断条件？满足条件执行的代码块：不满足条件执行的代码块 多分支语句：用于2个条件以上，每个条件都有一个结果的情况 语法结构：---（重点） if （判断条件1） { 满足条件1执行的代码 } else if （判断条件2）{ 满足条件2执行的代码 } else if （判断条件3）{ 满足条件3执行的代码 } ... else{ 全部条件都不满足执行的代码（根据项目要求写） } switch----利用循环实现条件判定执行的语句 语法结构： switch (条件判断的变量) { case 比较值1（精确值）： 满足条件1的执行代码 break case 比较值2（精确值）： 满足条件2的执行代码 break ... default: 全部条件都不满足执行的代码（根据项目要求写） break } 【注意】只能判断精确值，不能判断范围值 for循环语句的使用 循环的定义：把同样的事件以定义好的次数来运行完毕的过程叫循环 循环的四大要素—–（面试题） 循环初始变量 设置这个变量的变化和范围 循环体 循环执行代码 for循环的语法结构：---（重点） for （let a=0;a&lt;5;a++） { 循环执行代码 } while循环 语法结构： let a=0; while (a&lt;5) { 循环执行代码 a++ } do while循环 【特点】先不管条件符合与否执行一次代码在来比对条件 语法结构： let a=0; do { 循环执行代码 a++ } while (a&lt;5) 流程控制语句break、continue的使用 break—–终结并退出循环 continue—–跳过当前循环 JavaScript函数函数的作用与定义 函数：在编写代码过程中，我们会使用到一段代码在很多页面实现功能，但是如果复制粘贴，以后修改维护很麻烦所以我们使用函数来封装这段代码，在你需要的地方只用调用就可以实现操作了 自定义函数的两种方法 声明式 语法结构： function 函数名 (形参1，形参2...) { 函数执行内容 return 局部变量名（根据项目要求可写可不写） } 表达式 语法结构： let 变量名 = function (形参1，形参2...) { 函数执行内容 return 局部变量名（根据项目要求可写可不写） } 调用 声明式调用：函数名（实参1，实参2） 表达式调用：变量名（实参1，实参2） 变量的作用域 全局作用域 定义在函数之外的变量就是全局作用域 局部作用域 定义在函数之内的变量就是局部作用域 【区别】：全局变量可以在任何位置使用，局部变量只能使用在函数中 形式参数的使用 形式参数的定义：通过设置局部变量来实现全局变量转换使用的方法 【注意】如果函数中局部变量有和全局一样名字的变量，那么在函数中要使用全局变量就只能用形式参数传入使用。形参可以有多个，按照顺序赋值 return返回值的使用 return 变量名 把局部数据返回到全局操作 系统函数的意义 自定义函数 我们自己创建的函数，内容我们自己添加 系统函数 js的作者在编写这个语言的时候就把函数编写好了，我们只用调用来使用就可以了 alert()document.write()console.log()parseInt()parseFloat()isNaN(值)—-判断数字类型是不是不是一个数字 是一个数字—–false 不是一个数字—true【提示】当前只判断值不判断类型 JavaScript数组数组的定义 数组：属于复合数据类型，普通的变量只能装一个类型的数据，如果做数据的赋值就会把前一个数据给清除掉，我们使用数组就是让一个变量可以同时装载很多种数据类型和个数的结构体 数组的定义： 实例化 let arr = new Array（） 字面量—–[重点] let arr = [] 数组中数据的增删改查 添加数组的数据—–重点 三种方法 直接在空数组中依次填写数据用逗号分开 arr = [数据1，数据2..] 使用索引添加值arr[索引] = 数据 【注意】尽量按照顺序添加数据，不要出现空隙数组 使用数组的方法push（）—–按照当前的索引依次添加arr.push(数据) 删除数组的数据 delete 数组[索引]—–会留下空位不适用 pop()—–删除最后一个数据—–重点arr.pop() 指定删除 arr.splice(开始删除的位置，删除几个) 修改数组的数据 使用索引修改数据—–重点arr[索引] = 新数据 查询数组的数据 使用索引获取数据—–重点arr[索引] for循环遍历数组与forEach（）的认识for (let i=0;i&lt;arr.length;i++) { console.log(arr[i]) } arr.forEach(function(item,index) { console.log(item) }) 二维数组：数组中的数据不再是基本数据，而也是数组 数组的内置函数【重点】 重点掌握—-(重点) push()—–像数组的末尾添加一个或更多的元素 pop()—–删除数组最后一个元素 arr.splice（开始的地方，删除个数，添加值）—–可以实现数组的增删改查 ​ concat()—–合并两个或更多的数组 ​ shift()—–从左到右删除 ​ unshift()—–从右到左添加 ​ slice()—–查询数组具体指—–左闭右开 JavaScript对象对象的含义 对象： 万事万物皆对象，很多的属性和方法集中在一起就构成了一个对象，我们学习的对象就是以一个键值对形式来存储一个归类好的对象下所有的属性和方法的数据结构 对象的创建对象中数据的增删改查 定义对象—–自定义对象 实例化 let obj = new Object（） 字面量—–【重点】 let obj = {} 添加对象值 键值对—–重点 {键名1：值1，键名2：值2，键名3：值3…} 在字面量中直接添加键值对 通过键名直接添加 查询具体值—–重点 obj.键名 修改具体值—–重点 obj.键名 = 值 删除数据—–重点 delete obj.键名 遍历对象的值—–【重点】for (let key in obj) { key-----键名 obj[key]-----键值 } 函数中this的认识 函数中的this指代的就是调用函数的对象自己 &lt;div id=&quot;box&quot;&gt;我是div的文字&lt;/div&gt; &lt;script&gt; let box = document.getElementById(&quot;box&quot;) console.log(box); box.onclick = function () { // console.log(this); this.style.color = &quot;red&quot; this.style.backgroundColor = &quot;black&quot; this.style.width = &quot;300px&quot; this.style.height = &quot;120px&quot; } &lt;/script&gt; 内置对象的属性与方法 String对象 属性：length—–重点 str.length 方法—–重点 indexOf（检索字符，开始位置的索引） str.indexOf() 【注意】查询有的字符返回排位的索引， 查询没有的字符，返回-1 replace（要被替换的字符，用来替换的字符）【注意】使用正则替换所有匹配字符 /匹配字符/g substr（开始索引，截取长度） charAt（index）—–index（排位索引) substring（开始索引，结束索引（不包含））—–左闭右开 Number对象 tofixed（index）—–固定小数位数 【特点】四舍五入，输出的是字符串 Math对象—–【重点】 ceil()—–向上取整 floor()—–向下取整 round()—–四舍五入 random()—–随机数0-1之间（左闭右开） 范围取值：Math.floor(Math.random()*(max-min+1)+min) Date对象—–获取时间 let date = new Date() let year = date.getFullYear() console.log(year); let month = date.getMonth()+1 console.log(month) let day = date.getDate() console.log(day); let h = date.getHours() console.log(h); let m = date.getMinutes() console.log(m); let s = date.getSeconds() console.log(s); let str = &quot;现在时间是&quot;+year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;+h+&quot;时&quot;+m+&quot;分&quot;+s+&quot;秒&quot; document.write(str) BOM和DOMBOM的认识 BOM：浏览器对象模型，我们使用js就是为了操作浏览器中的一些属性和方法（alert()） BOM顶层对象中的属性和方法 BOM的顶层对象是window【顶层对象的属性和方法可以省略主题，直接调用】 alert()//ok window.alert()//good 顶层对象的属性和方法—–【重点】 let t = setInterval(执行函数，间隔时间（毫秒）)——间歇计时器 clearInterval（t）—–关闭计时器 setTimeout(执行函数，时间（毫秒）)—–演示计时器 scrollTo（水平位移，竖直位移）—–滚动条移动到指定位置 其他对象 screen—–屏幕对象 availWidth 显示器屏幕可用宽度，除任务栏外 availHeight 显示器屏幕可用高度，除任务栏外 Width 实际宽 Height 实际高 history对象 length—–获取访问路径的长度 back（）—–返回上一页 forword（）—–前进下一页 go（index）—–前进（正值）或后退（负值）inex页 location对象 heaf—–设置路径进行跳转 DOM的认识 节点树 文档—–document—–文档节点 标签—–element—–元素节点 文本—–text—–文本节点 属性—–attr—–属性节点 document是DOM的顶层对象 获取元素的四个方法重点： 通过id获取元素 document.getElementById(&quot;id值&quot;) 了解： 通过标签名获取元素 document.getElementsByTagName(&quot;元素名&quot;) 通过name属性获取元素 document.getElementsByName(&quot;name值&quot;) 通过类名获取元素 document.getElementsByClassName(&quot;类名&quot;) H5中新的选择器操作【重点】 document.querySelector—–单个选择 document.querySelectorAll—–多个选择 js基本操作css和属性的认识【重点】 innerHTML—–把内容写入指定标签中 属性操作 获取元素.属性名 = 值 （className） css操作 【注意】只能操作内嵌式css 获取元素名.style.样式名 = 值 DOM文档对象模型的深入认识DOM的定义 DOM：文档对象模型，是BOM下的一个小对象，有个顶层对象叫document主要的属性和方法都是操作html文件中的标签，属性，css和超文本内容的。 html和body的图书节点取法—–【重点】html和body的特殊节点取法：---(重点) html: document.documentElement body: document.body H5获取html和body标签： document.querySelector(&quot;选择器&quot;) 节点的操作[增删改查] 查询元素节点方法 DOM：4种 H5：2种 节点属性【重点】 parentNode 父节点 firstChild 列表中的第一个节点 firstElementChild 第一个子元素节点 lastChild 列表中的最后一个节点 lastElementChild 第一个子元素节点 【注意】获取的第一或最后的子级元素都是text（换行符号） childNodes 所有子节点的列表 previousSibling 上一个兄弟节点 previousElementSibling 上一个兄弟元素节点 nextSibling 下一个兄弟节点 nextElementSibling 下一个兄弟元素节点 children 子节点 children[0] 第一个子元素节点 children[children.length-1] 最后一个子元素节点 节点的创建、修改与删除【重点】 创建元素标签—–重点 let div = document.createElement(&quot;标签名&quot;) 添加子级元素—–重点 父级元素.appendChild(在父级元素的最后面添加元素标签) insertBefotr(创建元素，指定元素）-----在指定元素前面添加元素标签 节点的修改—–重点 父级元素.replaceChild(用来替换的子元素，被替换子元素) 节点的删除—–重点 父级元素.removeChild(子级元素) 节点的复制 元素标签.cloneNode（）----复制一个标签，如果括号参数为空或者false是浅拷贝只复制标签不复制里面的内容 是true的话就是深拷贝会完整赋值标签与标签的内容 事件的四大要素常用事件事件的四大要素【面试题】 事件源：发生事件的元素标签 事件类型：事件的种类或触发效果 事件执行内容：事件触发后执行的的代码块 事件对象：就是记录事件发生到结束之间的所有事情并可以使用相关方法属性调用需要的记录 事件注册2种掌握方式—–重点 1.元素.on事件名 = function （） { 执行代码 } 2. box.addEventListener(&quot;不带on的事件名&quot;,function(){ 执行代码 }) [注意]普通的事件相同名字的事件重复定义会覆盖以前事件，使用监听方式添加的事件事件名重复，但是所有事件都会执行。 重点常用事件—–重点 click——点击事件 mouseover—–鼠标移入事件 mouseout—–鼠标移出事件 blur——元素失去焦点 focus—–元素获取焦点 必须使用在input标签上的 input 输入事件 change 用户改变域的内容 预加载 load—–预加载 window.onload = function () { 所有js代码 } jQuery的选择器与属性操作jQuery的认识与基本引入操作 jQuery： 它是把原生的js属性和方法封装成更加简单的更能的集合，我们把这个集合叫一个库（插件），它的特点就是写的少，做的多。我们一般使用1.X系列，对主流浏览器的支持高，一般使用压缩版，节约空间 jQuery的基本使用步骤 下载相关的jQuery版本（bootcdn上输入jquery找到1.12.4版本） 把文件引入相关的html文件中 打印jQuery或者$确认是否引入成功 jQuery的选择器 jQuery选择器语法结构 $(‘选择器’) 常用选择器—–重点 :first—获取第一个元素:last—-获取最后一个元素:eq(index)—-获取指定索引的元素:odd—-获取奇数索引的元素:even—获取偶数索引的元素 jQuery操作css样式【重点】 $(‘选择器’).css(‘样式名’)—–获取样式值 $(‘选择器’).css({样式名1：值1，样式名2：值2}) 优点：任何位置的css样式都可以操作 jQuery中属性的操作jQuery对象【重点】 获取自定义属性 jq对象.attr({&quot;属性名&quot;：&quot;值&quot;}) jq对象.attr(&quot;属性名&quot;) 获取标准属性 jq对象.prop({&quot;属性名&quot;：&quot;值&quot;}) jq对象.prop(&quot;属性名&quot;) jQuery中类名的操作【重点】 jQuery对象.addClass(‘类名 类名’) ==== 添加类名jQuery对象.removeClass() ==== 删除所有类名jQuery对象.removeClass(参数) ==== 删除所有指定类名jQuery对象.hasClass(‘类名’) === 判断元素对象中是否含有指定类名 ： true/falsejQuery对象.toggleClass(‘类名’) === 判断元素对象中是否含有指定类名： jQuery的遍历与DOM操作jQuery对元素节点的增删改查【重点】查询方法（父子和兄弟之间）【重点】 jq js children()—获取当前元素的所有或指定子级元素 childnodes next()—-获取兄弟的下一个元素 nextsibling prev()—-获取兄弟的上一个元素 prevorsibling siblings()—获取除当前元素以外的所有兄弟级 无 find()—–后代级选择器 无 parent()—-获取父级 parentNode parents()—-获取父级们 无 index()—获取队列索引 eq(index)—通过索引找标签 创建和添加方法【重点】 ​ jq js$(“html代码”) document.creatElement(“标签名”)append() appendTo()—父子添加 appendChild()after()—兄弟级添加 无 删除方法【重点】 全部清空子级：empty（）指定删除：remove（） jQuery中each（）遍历标签的使用【重点】$(&quot;ul&gt;li&quot;).each(function (i,d) { console.log(i(索引),原生对象); }) jQuery中设置文本的方法 ​ jq js 普通标签设置文本 $(“选择器”).html(“值”) 元素对象.innerHTML = “值”input预先存值 $(“选择器”).val(“值”) input.value = “值” jQuery事件与动画jQuery的预加载 $(function () { jq代码 }) jQuery中on事件做绑定和委派的操作以及off注销事件事件绑定—【重点】 $(jq对象).on(&quot;事件名&quot;,function(){ 事件执行代码 }) 事件绑定的效果和js的监听事件一样都可以重复添加事件 注销事件： $(&quot;jq对象&quot;).off(&quot;指定事件&quot;) 【注意】不能用于事件派发 事件委派—【重点】$(&quot;父级元素&quot;).on(&quot;事件名&quot;,&quot;子级元素&quot;,function () { 代码操作 }) 针对未来元素统一具有同样事件的操作 事件对象的方法认识【重点】 event.target—–获取事件源 event.type—–获取事件类型 event.preventDefault()—–阻止默认事件行为 jQuery中的封装动画与自定义动画的操作封装动画—【重点】 show() : 显示hide() : 隐藏toggle() : 切换显示/隐藏 slideUp() : 滑入slideDown() : 滑出slideToggle() : 切换滑入/滑出 fadeIn() : 淡入fadeOut() : 淡出fadeToggle() : 切换淡入/淡出 自定义动画—【重点】 jq对象.stop(true).delay(延时时间).animate( {样式名1：“值1”,样式名2：“值2”}, 运动时间, fn )","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"js入门","slug":"js入门","permalink":"/tags/js入门/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Css","slug":"Css","date":"2020-11-23T01:20:13.000Z","updated":"2021-07-25T19:25:57.405Z","comments":true,"path":"2020/11/23/Css/","link":"","permalink":"/2020/11/23/Css/","excerpt":"","text":"CSS入门基础与选择器web网页构成的四个部分与作用（面试题） web—–网站 H5—–狭义(html5)—–广义(html5,css3,JavaScript) web的四个构成部分 内容：超文本 结构：html4.0.1 XHTML1.0 html5 表现：css2.1 3 行为：JavaScript css的相关迭代历史与css的基本书写结构及三种引用方式 就是用来实现网页中超文本细节设置的代码，中文名叫层叠样式表，简称样式表层叠：由于html标签有嵌套关系，也叫做父子关系，在css中就把这个关系叫层叠，父辈级拥有的css样式，子级同样也拥有 三种引用方式： 内嵌式：语法结构：&lt;标签名 style=”样式名1:样式值1;样式名2:样式值2;”&gt;文本内容&lt;/标签名&gt; 内部式：1.在head标签中书写一对style标签 2.在style标签中书写css的基本结构 css的基本语法结构：—–(重点) 选择器{ 样式名1:样式值1; 样式名2:样式值2; 样式名3:样式值3; } 外链式—–强烈推荐—–【重点】- #### 1.创建一个后缀名为css的文件 - #### 2.把写在内部式中的css结构直接写在创建好的文件中保存 - #### 3.通过head中使用link标签把对应的css文件引入html中使用 css选择器的使用 选择器的概念：就是我们给指定标签设置的名字，用来获取以后执行设置的样式细节效果 基本选择器—–重点 id选择器—设置一个独一无二的名字来代替这个标签做样式设置的名字 获取指定的单个标签使用 (#id的值—选择器) class类选择器—给多个需要统一设置样式的标签统一取一个名字来操作 .class的值—选择器 tag（标签选择器）—-以标签的名字作为选择器来使用*（通用标签）—-所有标签都会执行这个样式设置,—-分组 层次选择器—–重点 子级选择器 父级标签&gt;子级标签—-获取父级下的第一层子级元素标签 后代选择器 空格 父级标签 后代级标签—–获取父级下所有满足后代级标签的标签 伪类选择器:表现的一种状态的操作 a标签： 选择器:伪类 :link----未访问的状态 :visited---访问后状态 :active----点击状态 重点认识：----（重点） :hover----鼠标放置状态（鼠标移入移出状态） a{ color: black; /* 取消下划线 */ text-decoration: none; } a:hover{ color: blue; } font-weight:bold;----文字加粗 text-align:center---文字水平居中 CSS的继承与优先级及文字样式继承的定义与权重值 继承的定义：在父辈级设置的css样式子级和后代级都会拥有这个样式，这就叫做继承 权重值—–重点 定义：人为规定的一些数值，用来帮助我们计算优先级的操作 !important&gt;内嵌式&gt;id&gt;class&gt;tag,*,继承，其他 字体属性中的重点样式重点掌握—–重点font-family----设置字体样式 font-size----改变字体大小 font-weight---字体加粗 color----改变字体颜色 line-height----设置行高 特殊操作： 在一个有宽高的盒子（标签）里如果只有一行文字，我们可以使用text-align做水平文字居中 使用line-height设置为和高度一样就可以实现竖直方向居中 text-decoration: none取消任何线条 underline添加下划线 line-through添加贯穿线 了解 font---复合属性 font-style----字体倾斜 文本属性中的重点样式重点掌握—–重点 text-align----文字水平对齐 text-indent---文字首行缩进 段落2em 输入框的操作文字后移 了解： vertical-align----垂直布局（top|middle|bottom）只能用于图片和td中 text-overflow----生成省略号 字体阴影的使用与设置 text-shadow: 阴影的水平位移 阴影的竖直位移 阴影的浓淡 阴影的颜色; CSS背景盒子模型基础盒子模型的概念（区分块元素标签div与行内元素标签span的差别） 盒子模型的概念 布局标签：div span 布局标签主要用来规划布局内容，和我们使用盒子装东西是一个概念，所以我们把布局标签就看成一个盒子 特性 内容（超文本）设置尺寸 内边距 边框 外边距 背景 块级元素标签和行内元素标签的区别—–重点—–面试题1. 块级元素默认有一个宽度100%，没有高度，行内元素没有宽高 2. 块级元素默认独占一行，行内元素默认水平排列 3. 块级元素可以设置宽高，行内元素不能设置宽高--由内容撑开 4. 块级元素可以使用外边距，行内元素，只有左右可以使用 标签的尺寸操作【重点】 width—设置高度 height—设置宽度 min-height—设置最小高度【注意】只有块级元素才可以操作 标签背景设置的符合央视以及分支样式的使用【重点】 分支样式 background-color:设置标签背景颜色 background-image: url(“文件路径”);—设置背景图片 background-repeat: no-repeat;—取消背景图平铺效果 background-position: 水平位移 竖直位移;移动背景图片的位移 居中：50%;center; css3: background-size: 调整背景图大小尺寸 复合样式 backgroud: 颜色 url(“文件路径”) no-repeat center; 内边距 内边距的定义：是内容和标签边框之间的距离 特点：一旦添加内边距，标准的标签会改变大小，我们为了保证原始设置的大小会在你设置的大小中减去设置的内边距 复合样式 padding 一个值：上下左右 两个值：上下 左右 三个值：上 左右 下 四个值：上 右 下 左 分支样式 padding-top:上 padding-bottom：下 padding-left:左 padding-right:右 【注意】块级标签都可以使用，行内标签上下使用会出现问题 外边距【重点】 外边距的定义：是标签与标签之间的距离，我们有时候使用这个外边距来实现移动标签 复合样式 margin 一个值：上下左右 两个值：上下 左右 三个值：上 左右 下 四个值：上 右 下 左 分支样式 margin-top:上 margin-bottom：下 margin-left:左 margin-right:右 margin: auto;—–标签居中 特点：使用居中的样式的标签必须是div，需要有一个小于父级标签宽度的值 外边距塌陷（沉降） 父级和子级的上边框重合 方法：父级实现透明边框或者使用内边距撑开距离 外边距重合 把距离设置给一个元素 边框的使用 注意：边框的设置也会改变标签的大小 复合样式 border：边框粗细 边线样式 颜色 分支样式 border-top:上 border-bottom：下 border-left:左 border-right:右 CSS盒子模式与浮动布局标准盒子与怪异盒子的区别 PC端使用的标签都是标准盒子 有声明（标准） 没有声明（怪异） 标准盒子—–重点 实际盒子的宽高 = 设置的宽高 + 设置的内边距 + 设置的边框 怪异盒子—–重点 实际盒子的宽高 = 设置的宽高 css转换—–重点 box-sizing: content-box;—标准盒子 box-sizing: border-box;—怪异盒子 移动端使用怪异盒子模型—–flex布局 浮动的基本操作 浮动的概念：在当前的平层上如果一个标签元素实现的浮动，那么它会脱离文本流，去到另外一个平层中，那么它原来占据的位置会被后来的标签替代。这个是使用浮动的基本状态。 语法结构：float：left || right 作用：浮动就是让我们之前的块级元素可以进行水平从左往右排列或者从右往左排列的操作。 浮动的清除方式 在最后做完浮动的元素同级的后面添加一个div实现css：clear：both； 给包裹所有浮动元素的父级设置一个和元素一样的高度 给包裹所有浮动元素的父级设置一个overflow：hidden； 通过父级设置伪元素来实现清除浮动的操作 伪类：：伪类状态 伪元素： ：：伪元素（before || after || placehoder） 伪元素的原理： 在父级的最后里面使用一个虚拟生成的标签，我们可以控制标签的形态再使用css添加clear：both 优势：虚拟标签下不会影响页面结构布局和样式设置 .clearfix::after{----(重点) content:&quot;&quot;; display: block; clear: both; height: 0; visibility: hidden; } 解决浏览器兼容问题 .clearfix { *zoom: 1; } 浮动实现的常用布局状态 列表布局 左右结构布局 左中右结构布局 CSS定位定位的基本使用状态（先激活在使用） 定位的概念：就是吧我们需要的元素指定移动到某一个位置上去，实现一些元素的重叠操作。 position: absolute(绝对定位) || relative(相对定位) || fixed(固定定位)\\ 使用定位的步骤 先使用position激活定位，目前你是看不见移动的变化的 使用方向位移来实现元素的移动 先确定起始点 再从这个起始点开始进行移动 语法结构：---(重点) XXX{ position:absolute; top:0px; left:0px; } 三种定位的特性与操作方式 absolute(绝对定位) 元素会脱离文本流 因为使用绝对定位会出现布局错乱，我们使用父级包裹（父级要有高度）来避免布局错乱 如果父级没有做定位，子级定位按照浏览器来操作 父级有相对定位，子级就会按照父级的四个点来定位操作 relative(相对定位) 使用相对定位不会脱离文本流！ 从目前所在的位置为起点开始进行位移操作 fixed(固定定位) 脱离文本流，一般写在最末尾 不会随着浏览器的滚动而移动 子绝父相的定位方式与相对居中的操作方式【重点】 子绝父相：子级元素使用绝对定位，父级元素使用相对定位保障后面布局不会错乱 父级元素{ position：relative } 子级元素{ position：absolute top：xxpx; left:xxpx; } 绝对居中：利用定位把要居中的元素移动整个宽度的一般和高度的一半，然后配合margin把元素的中心点移动到父级的中心点 #father&gt;.son{ width: 300px; height: 200px; background: rgb(179, 43, 88); position: absolute; top: 50%; left: 50%; margin-top: -100px; margin-left: -150px; } 相对居中：把子级元素先用margin：auto移动到左右居中的位置，然后使用定位四个方向设置同样的值来实现一种可以理解为受力平衡来达到定位到中间的概念【重点】 #father&gt;.son{ width: 300px; height: 200px; background: rgb(179, 43, 88); margin: auto; /* 相对居中 受力平衡 */ position: absolute; top: 0; left: 0; right: 0; bottom: 0; } CSS3的常用样式CSS3中的child系列与type系列的区别【重点】 作用：如果我们要选择父级下一个同级存在的队列（同级关系）元素的任意一个元素的时候，不需要添加单独的id或者类名，只要知道这个标签的排列顺序就可以获取到它来操作了。 `html css3—结构伪类选择器 child系列：---（重点） :first-child-------获取纯队列中第一个元素标签 :last-child-------获取纯队列中最后一个元素标签 :nth-child(index)----index代表当前想要获取的标签在纯队列中的序号 type系列：----（重点） :first-of-type-------获取（纯|杂）队列中第一个元素标签 :last-of-type-------获取（纯|杂）队列中最后一个元素标签 :nth-of-type(index)----index代表当前想要获取的标签在（纯|杂）队列中的序号 ` 总结：只要是child系列能获取的队列type系列都可以操作。在杂队列中，只有type系列可以获取内容，child不行。杂队列的类名不能取成相同的类名。 css3中过渡动画的操作 过度：tarnsition:[transition-property(参与过渡的样式)] || [transition-duration(设置过渡时间)] || [transition-timing-function(过渡特效)] || [transition-delay(延时)] 特点：过渡必须写在原来的css设置中，必须填写前两个值 display的了解 display：none（隐藏）|| block（显示） || inline-block（转化为行内块元素） Css常见样式文字与图片对齐 vertical-align:bottom —–文字与图片底部对齐 vertical-align:top—–文字与图片顶部对齐 vertical-align:middle—–文字与图片垂直居中对齐 文本溢出隐藏单行文本 white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 多行文本 display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;overflow: hidden; &amp;lt；小于符号 &amp;gt；大于符号","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"css样式","slug":"css样式","permalink":"/tags/css样式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"HTML","slug":"Html","date":"2020-10-15T12:10:23.000Z","updated":"2021-07-25T19:27:20.629Z","comments":true,"path":"2020/10/15/Html/","link":"","permalink":"/2020/10/15/Html/","excerpt":"","text":"HTML（入门基础与布局标签）（超文本标记语言）HTML的定义 定义：使用标签进行编辑让浏览器把我们想要给用户展示的超文本按照理想的解构显示出来的语言。 静态页面和动态页面的区别(面试题) 静态页面： 当写完前端代码后，不做任何修改，在不同时间，空间，地点，打开浏览器，看到的状态是一样的。 动态页面： 当写完前端代码后，不做任何修改，在不同时间，空间，地点，打开浏览器，由于后台数据发生变化看到的状态不一样。 三个版本和一个标准 迭代—-升级 三个版本 HTML4.0.1—–pc端—–经典 XHTML1.0—–语法严格 HTML5—–新技术—–移动端专用 一个标准 W3C—–万维网联盟 开源 HTML的基本结构【重点】 &lt;!DOCTYPE html&gt; -----声明（指代强调我们现在使用的文档是html做的编辑操作，浏览器按照html的编译来显示） 标签的认识： 单标签：&lt;标签名&gt; 双标签：&lt;标签名&gt;&lt;/标签名&gt; 书写一对html标签—–规范所有html代码的书写范围 在html中书写一对head标签—–对超文本做细节设置的内容都放在这里面 1.&lt;meta charset=&#39;UTF-8&#39;&gt;-----设置字符集为国际通用编码防止中文乱码 2.&lt;title&gt;&lt;/title&gt;-----修改网页的标题 书写一对body标签—–我们需要给用户展示的所有内容代码都写在body中 属性的定义和使用状态【特性】 属性必须写在开始标签中 以属性名=’属性值’来设置细节操作 多个属性用空格隔开 语法结构： 双标签： &lt;开始标签 属性名1=“属性值1” 属性名2=“属性值2”&gt;&lt;/结束标签&gt; 单标签： &lt;单标签 属性名1=“属性值1” 属性名2=“属性值2”&gt; 重点标签的结构与使用方法【重点】 hn系列标签 文本标题标签（n代表1-6） 1.文字会大小变化 2.文字会加粗 3.默认独占一行 4.上下有很大的间距 p标签 段落标签 br标签—-换行 了解: 加粗标签 b(html4) strong(html5) 倾斜标签 i(html4) em(html5) 渐变缩小 small 渐变放大 big 分割线标签 hr 中文空格&emsp; 英文空格&amp;nbsp； HTML 超链接 多媒 列表新语义标签的含义 通过标签命就知道它要做什么事情的标签 a标签的两种常用链接方式和可被js替代的链接方式【重点】 超链接的定义 通过设置 一个文件的路径，点击超链接标签让浏览器跳转显示的操作 语法结构： &lt;a href=&quot;设置跳转路径&quot;&gt;文本内容&lt;/a&gt; 【特点】文字没访问蓝色 访问以后是紫色 自带下划线 三种连接方式—重点 外链式：网站跳网站 域名发生变化 域名（以http://或者https://开头的路径） 内联式：同一个网站从一个页面跳转到另一个页面 锚点链接：利用a标签实现坐标的操作，点击跳转到同一页面的不同位置 相对路径与绝对路径的区别与使用【重点】 绝对路径：从http://或者https://以及’/‘还有盘符（C:D:E:F)开头的路径都叫做绝对路径 相对路径：从开始写链接标签的文件作为起点，去找要访问的重点文件的路径 同级查找: ./目标文件名文件夹向下查询: ./文件夹名/目标文件名返回上一个层级：../目标文件名 图片标签的使用与相关属性的认识image:&lt;img&gt;(单标签) src图片路径 语法结构：---（重点） &lt;img src=&quot;图片相对路径&quot;&gt; 图片：jpg(有背景颜色),png,gif 相关属性认识： alt-----一旦图片路径加载错误出现的提示说明 title-----图片正常加载显示后鼠标移入图片上出现的文字提示说明 width-----设置图片大小等比例缩放（不需要单位可以是百分比） h5中新的多媒体标签的基本操作音频标签：audio 双标签 src音频路径 controls 语法结构wu &lt;audio src=&quot;音频路径&quot;&gt;&lt;/audio&gt; 视频标签：video 双标签 src音频路径 controls poster 语法结构： &lt;video src=&quot;视频路径&quot;&gt;&lt;/video&gt; HTML表格与表单表格的作用与相关属性 表格的定义：由很多个单元格按照行和列的排布实现的一个整体，用来展示归类的数据排列 表格的使用 table—-双标签—-占位实现一个表格 tr——-双标签—-表格的行 td——-双标签—-表格单元格 语法结构：---（重点） 3*3表格 &lt;table&gt; &lt;tr&gt; &lt;td&gt;1-1&lt;/td&gt; &lt;td&gt;1-2&lt;/td&gt; &lt;td&gt;1-3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2-1&lt;/td&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;td&gt;2-3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3-1&lt;/td&gt; &lt;td&gt;3-2&lt;/td&gt; &lt;td&gt;3-3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 相关属性 border----边框属性 cellspacing----改变单元格的间距 cellpadding----改变文字和单元格边框距离 width-----设置宽度 height----设置高度 align-----用在table上表格水平居中，用在td上文字水平居中 bgcolor----改变背景颜色 表格合并： 横向合并 colspan---横向合并 纵向合并 rowspan--纵向合并 tbody---是浏览器编译代码后生成的一个表格体的标签 表单的基本结构搭建 表单的定义与作用：表单就是我们使用一些输入框和提交按钮来实现用户输入数据的采集以及发送的标签结构 表单的基本创建 form—–双标签—表单标签—一般写在最外层 action—–设置数据发送的具体文件位置 method—–选择数据的提交方式（GET | POST） GET—-传输不安全，传输量小2kb POST—传输安全，传输量大 input—-单标签—输入框标签—收集用户数据 name—-定义数据名字 button—双标签—提交数据确认 type—–submit(默认值) 语法结构：-----（重点） &lt;form action=&quot;发送数据路径&quot; method=&quot;GET&quot;&gt; 用户名&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt; 密码&lt;input type=&quot;text&quot; name=&quot;pwd&quot;&gt;&lt;br&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; input中常用的属性和type中常用的变化值 重点属性—–重点value ----- 当input是输入框形态的时候设置其中输入的内容 当input是按钮状态的时候修改按钮显示的文字 placeholder----在输入框内提示输入内容，只要输入就不显示，不输入就显示 readonly----只读 disabled----禁用按钮 checked----默认选中 type： text(默认值)文本输入框 password----密码输入框 radio----单选框***必须使用相同的name才有单选的操作*** checkbox----多选框**变成按钮** submit----提交按钮 了解： button---普通按钮 reset--重置 file---文件上传 hidden---隐藏输入框 下拉选择框的组合操作和相关标签属性 下拉选择框的的定义：通过下拉选择获取相关数据 语法结构： &lt;select&gt; &lt;option&gt;请选择&lt;/option&gt; &lt;option&gt;中国&lt;/option&gt; &lt;option&gt;英国&lt;/option&gt; &lt;option&gt;法国&lt;/option&gt; &lt;/select&gt; textarea----多行文本域 label-----提高用户体验","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web页面","slug":"web页面","permalink":"/tags/web页面/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}